@Tutorial(time: 25) {
    @Intro(title: "게임 루프 & 성능") {
        SpriteKit의 게임 루프를 이해하고 
        성능을 최적화하는 방법을 학습합니다.
        
        @Image(source: "chapter10-performance.png", alt: "게임 루프와 성능")
    }
    
    @Section(title: "게임 루프 이해하기") {
        @ContentAndMedia {
            SpriteKit은 매 프레임마다 정해진 순서로 
            메서드를 호출하는 게임 루프를 실행합니다.
            
            **프레임 사이클 순서:**
            1. `update(_:)` - 게임 로직
            2. `didEvaluateActions()` - 액션 평가 후
            3. `didSimulatePhysics()` - 물리 시뮬레이션 후
            4. `didApplyConstraints()` - 제약 적용 후
            5. `didFinishUpdate()` - 프레임 완료
            
            @Image(source: "game-loop.png", alt: "게임 루프")
        }
        
        @Steps {
            @Step {
                update 메서드를 구현합니다.
                매 프레임 호출되며 게임 로직을 처리합니다.
                
                @Code(name: "GameScene.swift", file: "10-performance-01.swift")
            }
            
            @Step {
                델타 타임을 계산합니다.
                프레임 간 시간 차이를 사용하여 
                일관된 움직임을 구현합니다.
                
                @Code(name: "GameScene.swift", file: "10-performance-02.swift")
            }
            
            @Step {
                물리 시뮬레이션 후 로직을 처리합니다.
                `didSimulatePhysics()`에서 위치를 조정합니다.
                
                @Code(name: "GameScene.swift", file: "10-performance-03.swift")
            }
        }
    }
    
    @Section(title: "성능 모니터링") {
        @ContentAndMedia {
            SKView의 디버그 옵션을 활용하여
            게임 성능을 모니터링합니다.
            
            **디버그 옵션:**
            - `showsFPS`: 프레임 레이트
            - `showsNodeCount`: 노드 개수
            - `showsDrawCount`: 드로우 콜 수
            - `showsQuadCount`: 쿼드 수
            - `showsPhysics`: 물리 바디 시각화
            
            @Image(source: "debug-options.png", alt: "디버그 옵션")
        }
        
        @Steps {
            @Step {
                디버그 정보를 활성화합니다.
                개발 중 성능 지표를 확인합니다.
                
                @Code(name: "GameViewController.swift", file: "10-performance-04.swift")
            }
            
            @Step {
                프레임 레이트 목표를 설정합니다.
                `preferredFramesPerSecond`로 목표 FPS를 지정합니다.
                
                @Code(name: "GameViewController.swift", file: "10-performance-05.swift")
            }
            
            @Step {
                성능 문제를 진단합니다.
                노드 수, 드로우 콜 등을 확인하여 병목을 찾습니다.
                
                @Code(name: "GameScene.swift", file: "10-performance-06.swift")
            }
        }
    }
    
    @Section(title: "렌더링 최적화") {
        @ContentAndMedia {
            드로우 콜을 줄이고 렌더링 효율을 높이는 
            기법을 적용합니다.
            
            **최적화 기법:**
            - 텍스처 아틀라스 사용
            - 화면 밖 노드 제거
            - ignoresSiblingOrder 활성화
            - 불필요한 블렌딩 제거
            
            @Image(source: "render-optimization.png", alt: "렌더링 최적화")
        }
        
        @Steps {
            @Step {
                ignoresSiblingOrder를 활성화합니다.
                SpriteKit이 렌더링 순서를 최적화하도록 합니다.
                
                @Code(name: "GameViewController.swift", file: "10-performance-07.swift")
            }
            
            @Step {
                화면 밖 노드를 관리합니다.
                보이지 않는 노드는 제거하거나 숨깁니다.
                
                @Code(name: "GameScene.swift", file: "10-performance-08.swift")
            }
            
            @Step {
                블렌딩 모드를 최적화합니다.
                불필요한 알파 블렌딩을 피합니다.
                
                @Code(name: "GameScene.swift", file: "10-performance-09.swift")
            }
        }
    }
    
    @Section(title: "메모리 최적화") {
        @ContentAndMedia {
            메모리 사용량을 관리하여 
            안정적인 게임 실행을 보장합니다.
            
            **메모리 관리 팁:**
            - 텍스처 캐싱 활용
            - 사용하지 않는 리소스 해제
            - 약한 참조 사용
            - 메모리 경고 대응
            
            @Image(source: "memory-optimization.png", alt: "메모리 최적화")
        }
        
        @Steps {
            @Step {
                텍스처를 효율적으로 관리합니다.
                텍스처 캐시를 활용하고 필요시 해제합니다.
                
                @Code(name: "GameScene.swift", file: "10-performance-10.swift")
            }
            
            @Step {
                오브젝트 풀링을 구현합니다.
                빈번히 생성/삭제되는 객체를 재사용합니다.
                
                @Code(name: "BulletPool.swift", file: "10-performance-11.swift")
            }
            
            @Step {
                메모리 경고에 대응합니다.
                시스템 메모리 경고 시 리소스를 해제합니다.
                
                @Code(name: "GameViewController.swift", file: "10-performance-12.swift")
            }
        }
    }
    
    @Assessments {
        @MultipleChoice {
            게임 루프에서 가장 먼저 호출되는 메서드는?
            
            @Choice(isCorrect: true) {
                `update(_:)`
                
                @Justification(reaction: "정확합니다! 🔄") {
                    `update(_:)`는 프레임 사이클에서 
                    가장 먼저 호출되며, 
                    게임 로직을 처리하기에 적합합니다.
                }
            }
            
            @Choice(isCorrect: false) {
                `didEvaluateActions()`
                
                @Justification(reaction: "틀렸습니다.") {
                    `didEvaluateActions()`는 
                    `update(_:)` 이후에 호출됩니다.
                }
            }
            
            @Choice(isCorrect: false) {
                `didSimulatePhysics()`
                
                @Justification(reaction: "다시 확인하세요.") {
                    물리 시뮬레이션은 액션 평가 후에 
                    실행됩니다.
                }
            }
        }
        
        @MultipleChoice {
            렌더링 순서 최적화를 위해 설정하는 SKView 속성은?
            
            @Choice(isCorrect: true) {
                `ignoresSiblingOrder`
                
                @Justification(reaction: "맞습니다! 🚀") {
                    `ignoresSiblingOrder = true`로 설정하면
                    SpriteKit이 렌더링 순서를 자동 최적화합니다.
                    대신 zPosition으로 순서를 명시해야 합니다.
                }
            }
            
            @Choice(isCorrect: false) {
                `optimizeRendering`
                
                @Justification(reaction: "틀렸습니다.") {
                    이 속성은 존재하지 않습니다.
                }
            }
            
            @Choice(isCorrect: false) {
                `sortSiblings`
                
                @Justification(reaction: "다시 확인하세요.") {
                    올바른 속성명은 `ignoresSiblingOrder`입니다.
                }
            }
        }
        
        @MultipleChoice {
            델타 타임을 사용하는 이유는?
            
            @Choice(isCorrect: true) {
                프레임 레이트에 관계없이 일관된 게임 속도 유지
                
                @Justification(reaction: "정확합니다! ⏱️") {
                    델타 타임(프레임 간 시간 차이)을 곱하면
                    60fps든 30fps든 같은 속도로 
                    움직이도록 할 수 있습니다.
                }
            }
            
            @Choice(isCorrect: false) {
                더 부드러운 애니메이션을 위해
                
                @Justification(reaction: "직접적인 이유는 아닙니다.") {
                    델타 타임은 부드러움보다 
                    일관성을 위한 것입니다.
                }
            }
            
            @Choice(isCorrect: false) {
                메모리 사용량을 줄이기 위해
                
                @Justification(reaction: "관련이 없습니다.") {
                    델타 타임은 메모리와 관련이 없습니다.
                }
            }
        }
    }
}
