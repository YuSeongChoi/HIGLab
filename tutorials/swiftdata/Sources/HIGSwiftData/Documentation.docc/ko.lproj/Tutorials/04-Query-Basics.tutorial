@Tutorial(time: 15) {
    @Intro(title: "@Query의 마법으로 데이터 읽기") {
        @Query는 SwiftData의 꽃입니다.
        NSFetchRequest 없이, 선언적으로 데이터를 조회하고
        SwiftUI와 자동으로 동기화됩니다.
    }
    
    @Section(title: "@Query 기초") {
        @ContentAndMedia {
            @Query 프로퍼티 래퍼는 SwiftUI 뷰에서 데이터를 자동으로 가져옵니다.
            데이터가 변경되면 뷰도 자동으로 업데이트됩니다.
        }
        
        @Steps {
            @Step {
                **가장 간단한 @Query**
                
                타입만 지정하면 해당 모델의 모든 데이터를 가져옵니다.
                별도의 fetch 코드가 필요 없습니다!
                
                @Code(name: "TaskListView.swift", file: "04-query-basic.swift")
            }
            
            @Step {
                **정렬 추가하기**
                
                SortDescriptor로 결과를 정렬합니다.
                여러 정렬 기준을 조합할 수 있습니다.
                
                @Code(name: "TaskListView.swift", file: "04-query-sort.swift")
            }
            
            @Step {
                **기본 필터링**
                
                #Predicate 매크로로 타입 안전한 필터를 적용합니다.
                문자열 기반 NSPredicate와 달리 컴파일 타임 검증이 가능합니다.
                
                @Code(name: "TaskListView.swift", file: "04-query-filter.swift")
            }
        }
    }
    
    @Section(title: "@Query 심화") {
        @ContentAndMedia {
            @Query는 정렬, 필터링, 애니메이션 등 다양한 옵션을 지원합니다.
            FetchDescriptor를 사용해 더 복잡한 쿼리도 가능합니다.
        }
        
        @Steps {
            @Step {
                **복합 정렬**
                
                여러 SortDescriptor를 조합하면 다단계 정렬이 가능합니다.
                우선순위 → 생성일 순으로 정렬해봅니다.
                
                @Code(name: "TaskListView.swift", file: "04-query-multi-sort.swift")
            }
            
            @Step {
                **동적 필터링**
                
                @Query의 filter는 고정값입니다.
                동적 필터링이 필요하면 부모 뷰에서 조건을 변경합니다.
                
                @Code(name: "DynamicFilter.swift", file: "04-query-dynamic.swift")
            }
            
            @Step {
                **애니메이션 적용**
                
                animation 파라미터로 데이터 변경 시 애니메이션을 추가합니다.
                리스트 항목 추가/삭제가 부드럽게 표시됩니다.
                
                @Code(name: "AnimatedList.swift", file: "04-query-animation.swift")
            }
        }
    }
    
    @Section(title: "TaskMaster에 @Query 적용") {
        @ContentAndMedia {
            TaskMaster 앱의 메인 리스트에 @Query를 적용합니다.
            할 일 목록을 표시하고 완료 상태에 따라 필터링합니다.
        }
        
        @Steps {
            @Step {
                **TaskListView 구현**
                
                @Query로 모든 할 일을 가져오고 리스트로 표시합니다.
                아직 CRUD는 다음 챕터에서 구현합니다.
                
                @Code(name: "TaskListView.swift", file: "04-tasklist-view.swift")
            }
            
            @Step {
                **완료/미완료 필터**
                
                세그먼트로 필터를 선택하고 해당 항목만 표시합니다.
                동적 필터링 패턴을 적용합니다.
                
                @Code(name: "FilteredTaskList.swift", file: "04-filtered-list.swift")
            }
        }
    }
    
    @Assessments {
        @MultipleChoice {
            @Query의 데이터가 변경되면 SwiftUI 뷰는?
            
            @Choice(isCorrect: true) {
                자동으로 업데이트된다
                
                @Justification(reaction: "정답!") {
                    @Query는 Observable 패턴을 사용해
                    데이터 변경 시 뷰를 자동으로 업데이트합니다.
                }
            }
            
            @Choice(isCorrect: false) {
                수동으로 refresh() 호출이 필요하다
                
                @Justification(reaction: "아쉽네요") {
                    @Query는 SwiftUI와 자동 통합됩니다.
                    별도의 갱신 코드가 필요 없습니다.
                }
            }
            
            @Choice(isCorrect: false) {
                앱을 재시작해야 반영된다
                
                @Justification(reaction: "아쉽네요") {
                    @Query는 실시간으로 데이터 변경을 감지하고 뷰를 업데이트합니다.
                }
            }
        }
        
        @MultipleChoice {
            SwiftData에서 타입 안전한 필터를 만드는 매크로는?
            
            @Choice(isCorrect: true) {
                #Predicate
                
                @Justification(reaction: "정확합니다!") {
                    #Predicate 매크로는 컴파일 타임에 타입을 검증하여
                    문자열 기반 NSPredicate보다 안전합니다.
                }
            }
            
            @Choice(isCorrect: false) {
                #Filter
                
                @Justification(reaction: "아쉽네요") {
                    SwiftData에서는 #Predicate 매크로를 사용합니다.
                }
            }
            
            @Choice(isCorrect: false) {
                @Where
                
                @Justification(reaction: "아쉽네요") {
                    SwiftData에서는 #Predicate 매크로를 사용합니다.
                }
            }
        }
    }
}
