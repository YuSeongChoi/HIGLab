@Tutorial(time: 18) {
    @Intro(title: "정렬 & 필터링: 데이터를 원하는 대로") {
        #Predicate 매크로로 타입 안전한 필터를 만들고,
        SortDescriptor로 다양한 정렬을 구현합니다.
        동적 UI와 연동하여 사용자 맞춤 뷰를 완성합니다.
    }
    
    @Section(title: "#Predicate 심화") {
        @ContentAndMedia {
            #Predicate는 컴파일 타임에 타입을 검증하는 필터 매크로입니다.
            NSPredicate의 문자열 기반 위험성을 제거하고,
            Swift의 타입 시스템을 완벽히 활용합니다.
        }
        
        @Steps {
            @Step {
                **기본 Predicate 문법**
                
                클로저 형태로 조건을 작성합니다.
                프로퍼티 접근이 타입 안전하게 검증됩니다.
                
                @Code(name: "PredicateBasics.swift", file: "07-predicate-basics.swift")
            }
            
            @Step {
                **복합 조건 만들기**
                
                &&, ||, ! 연산자로 조건을 조합합니다.
                괄호로 우선순위를 명확히 지정할 수 있습니다.
                
                @Code(name: "PredicateComplex.swift", file: "07-predicate-complex.swift")
            }
            
            @Step {
                **문자열 검색**
                
                contains, localizedStandardContains 등으로 
                텍스트 검색을 구현합니다.
                
                @Code(name: "PredicateString.swift", file: "07-predicate-string.swift")
            }
        }
    }
    
    @Section(title: "SortDescriptor 활용") {
        @ContentAndMedia {
            SortDescriptor는 정렬 기준을 정의합니다.
            KeyPath를 사용해 타입 안전하게 정렬 프로퍼티를 지정합니다.
        }
        
        @Steps {
            @Step {
                **단일 정렬**
                
                하나의 프로퍼티 기준으로 오름차순/내림차순 정렬합니다.
                order 파라미터로 방향을 지정합니다.
                
                @Code(name: "SortBasics.swift", file: "07-sort-basic.swift")
            }
            
            @Step {
                **다중 정렬**
                
                여러 정렬 기준을 배열로 전달합니다.
                앞쪽 기준이 같을 때 뒤쪽 기준이 적용됩니다.
                
                @Code(name: "SortMultiple.swift", file: "07-sort-multiple.swift")
            }
            
            @Step {
                **옵셔널 프로퍼티 정렬**
                
                nil 값이 있을 수 있는 프로퍼티도 정렬 가능합니다.
                nil은 기본적으로 마지막에 위치합니다.
                
                @Code(name: "SortOptional.swift", file: "07-sort-optional.swift")
            }
        }
    }
    
    @Section(title: "동적 정렬/필터 UI") {
        @ContentAndMedia {
            사용자가 실시간으로 정렬/필터 조건을 변경할 수 있는 UI를 구현합니다.
            @Query의 init을 활용한 동적 쿼리 패턴을 배웁니다.
        }
        
        @Steps {
            @Step {
                **필터 옵션 열거형**
                
                필터 옵션을 열거형으로 정의합니다.
                각 옵션에 해당하는 Predicate를 반환하는 computed property를 추가합니다.
                
                @Code(name: "FilterOptions.swift", file: "07-filter-options.swift")
            }
            
            @Step {
                **정렬 옵션 열거형**
                
                정렬 기준을 열거형으로 정의합니다.
                사용자 친화적인 이름과 SortDescriptor를 매핑합니다.
                
                @Code(name: "SortOptions.swift", file: "07-sort-options.swift")
            }
            
            @Step {
                **동적 쿼리 뷰**
                
                부모에서 조건을 받아 @Query를 초기화합니다.
                조건 변경 시 뷰가 새로 생성되어 쿼리가 업데이트됩니다.
                
                @Code(name: "DynamicQueryView.swift", file: "07-dynamic-query.swift")
            }
            
            @Step {
                **완성된 필터/정렬 UI**
                
                Picker로 옵션을 선택하고 리스트가 실시간 업데이트됩니다.
                검색 바도 추가하여 완성도를 높입니다.
                
                @Code(name: "FilterSortView.swift", file: "07-filter-sort-view.swift")
            }
        }
    }
    
    @Section(title: "FetchDescriptor 고급 사용") {
        @ContentAndMedia {
            @Query 외에 직접 FetchDescriptor를 사용하면
            더 세밀한 제어가 가능합니다.
        }
        
        @Steps {
            @Step {
                **FetchDescriptor 구성**
                
                predicate, sortBy, fetchLimit 등을 
                FetchDescriptor로 조합합니다.
                
                @Code(name: "FetchDescriptor.swift", file: "07-fetch-descriptor.swift")
            }
            
            @Step {
                **페이징 구현**
                
                fetchLimit과 fetchOffset으로 페이지네이션을 구현합니다.
                대용량 데이터 처리에 유용합니다.
                
                @Code(name: "Pagination.swift", file: "07-pagination.swift")
            }
        }
    }
    
    @Assessments {
        @MultipleChoice {
            #Predicate에서 대소문자 구분 없이 문자열을 검색하려면?
            
            @Choice(isCorrect: true) {
                localizedStandardContains 사용
                
                @Justification(reaction: "정답!") {
                    localizedStandardContains는 대소문자와 악센트를
                    무시하고 지역화된 검색을 수행합니다.
                }
            }
            
            @Choice(isCorrect: false) {
                contains + lowercased() 조합
                
                @Justification(reaction: "아쉽네요") {
                    #Predicate 내에서 lowercased() 호출은 제한됩니다.
                    localizedStandardContains를 사용하세요.
                }
            }
            
            @Choice(isCorrect: false) {
                caseInsensitiveCompare 사용
                
                @Justification(reaction: "아쉽네요") {
                    이 메서드는 #Predicate에서 지원되지 않습니다.
                }
            }
        }
        
        @MultipleChoice {
            여러 SortDescriptor를 배열로 전달하면 어떻게 동작하나요?
            
            @Choice(isCorrect: true) {
                앞쪽 기준이 같을 때 뒤쪽 기준 적용
                
                @Justification(reaction: "정확합니다!") {
                    배열의 순서대로 우선순위가 정해집니다.
                    첫 번째가 같으면 두 번째로 비교합니다.
                }
            }
            
            @Choice(isCorrect: false) {
                모든 기준을 동시에 고려
                
                @Justification(reaction: "아쉽네요") {
                    순차적으로 적용됩니다. 먼저 첫 번째 기준으로 정렬하고,
                    같은 값끼리는 두 번째 기준으로 정렬합니다.
                }
            }
            
            @Choice(isCorrect: false) {
                랜덤하게 기준 선택
                
                @Justification(reaction: "아쉽네요") {
                    순서대로 우선순위가 적용됩니다.
                }
            }
        }
        
        @MultipleChoice {
            @Query의 filter를 동적으로 변경하려면?
            
            @Choice(isCorrect: true) {
                부모 뷰에서 조건을 변경하여 자식 뷰를 재생성
                
                @Justification(reaction: "정답!") {
                    @Query의 파라미터는 초기화 시 결정되므로,
                    조건이 변경되면 뷰를 새로 생성해야 합니다.
                }
            }
            
            @Choice(isCorrect: false) {
                @Query 프로퍼티에 직접 새 값 할당
                
                @Justification(reaction: "아쉽네요") {
                    @Query는 프로퍼티 래퍼로, 직접 재할당이 불가능합니다.
                }
            }
            
            @Choice(isCorrect: false) {
                query.refresh() 호출
                
                @Justification(reaction: "아쉽네요") {
                    그런 메서드는 없습니다. 뷰 재생성이 필요합니다.
                }
            }
        }
    }
}
