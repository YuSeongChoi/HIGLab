@Tutorial(time: 20) {
    @Intro(title: "관계의 기술: Task와 Category 연결하기") {
        실제 앱의 데이터는 서로 연결되어 있습니다.
        @Relationship 매크로로 모델 간 관계를 설정하고,
        삭제 규칙으로 데이터 무결성을 보장합니다.
    }
    
    @Section(title: "Category 모델 만들기") {
        @ContentAndMedia {
            할 일을 카테고리별로 분류하기 위해 Category 모델을 추가합니다.
            하나의 카테고리에 여러 Task가 속하는 1:N 관계를 설계합니다.
        }
        
        @Steps {
            @Step {
                **Category 모델 정의**
                
                이름, 색상, 아이콘을 가진 Category 모델을 만듭니다.
                고유 ID와 생성일도 포함합니다.
                
                @Code(name: "Category.swift", file: "06-category-model.swift")
            }
            
            @Step {
                **@Relationship 매크로 이해**
                
                @Relationship은 모델 간 연결을 정의합니다.
                deleteRule로 부모 삭제 시 자식 처리 방식을 지정합니다.
                
                @Code(name: "RelationshipBasics.swift", file: "06-relationship-basics.swift")
            }
        }
    }
    
    @Section(title: "양방향 관계 설정") {
        @ContentAndMedia {
            Task에서 Category로, Category에서 Task로 양쪽에서 접근할 수 있는
            양방향 관계를 설정합니다. inverse 파라미터가 핵심입니다.
        }
        
        @Steps {
            @Step {
                **Task에 Category 추가**
                
                TaskItem에 optional Category 프로퍼티를 추가합니다.
                할 일은 카테고리 없이도 존재할 수 있으므로 옵셔널로 설정합니다.
                
                @Code(name: "TaskItem.swift", file: "06-task-with-category.swift")
            }
            
            @Step {
                **Category에 Task 배열 추가**
                
                Category에서 소속 Task들에 접근할 수 있도록 배열을 추가합니다.
                inverse로 양방향 연결을 명시합니다.
                
                @Code(name: "Category.swift", file: "06-category-with-tasks.swift")
            }
            
            @Step {
                **완성된 양방향 관계**
                
                두 모델의 완성된 형태입니다.
                관계가 양쪽에서 자동으로 동기화됩니다.
                
                @Code(name: "Models.swift", file: "06-bidirectional-complete.swift")
            }
        }
    }
    
    @Section(title: "삭제 규칙 마스터") {
        @ContentAndMedia {
            deleteRule은 부모 객체 삭제 시 자식을 어떻게 처리할지 결정합니다.
            cascade, nullify, deny, noAction 중 상황에 맞는 규칙을 선택합니다.
        }
        
        @Steps {
            @Step {
                **cascade: 연쇄 삭제**
                
                부모 삭제 시 자식도 함께 삭제됩니다.
                "카테고리 삭제 = 소속 할 일 모두 삭제"가 필요할 때 사용합니다.
                
                @Code(name: "DeleteRuleCascade.swift", file: "06-delete-cascade.swift")
            }
            
            @Step {
                **nullify: 관계만 해제**
                
                부모 삭제 시 자식의 참조를 nil로 설정합니다.
                "카테고리 삭제해도 할 일은 유지"할 때 적합합니다.
                
                @Code(name: "DeleteRuleNullify.swift", file: "06-delete-nullify.swift")
            }
            
            @Step {
                **deny: 삭제 방지**
                
                자식이 있으면 부모 삭제가 실패합니다.
                데이터 무결성이 중요한 경우 사용합니다.
                
                @Code(name: "DeleteRuleDeny.swift", file: "06-delete-deny.swift")
            }
        }
    }
    
    @Section(title: "관계 활용 UI") {
        @ContentAndMedia {
            관계를 활용한 UI를 구현합니다.
            카테고리별 할 일 필터링과 카테고리 선택 피커를 만듭니다.
        }
        
        @Steps {
            @Step {
                **카테고리 선택 피커**
                
                할 일 생성/수정 시 카테고리를 선택하는 UI를 구현합니다.
                Picker와 @Query를 조합합니다.
                
                @Code(name: "CategoryPicker.swift", file: "06-category-picker.swift")
            }
            
            @Step {
                **카테고리별 필터링**
                
                선택한 카테고리의 할 일만 표시합니다.
                관계를 통해 쉽게 필터링할 수 있습니다.
                
                @Code(name: "CategoryFilterView.swift", file: "06-category-filter.swift")
            }
        }
    }
    
    @Assessments {
        @MultipleChoice {
            Category 삭제 시 소속 Task들도 함께 삭제하려면?
            
            @Choice(isCorrect: true) {
                @Relationship(deleteRule: .cascade)
                
                @Justification(reaction: "정답!") {
                    cascade 규칙은 부모 삭제 시 연결된 자식들도
                    함께 삭제합니다.
                }
            }
            
            @Choice(isCorrect: false) {
                @Relationship(deleteRule: .nullify)
                
                @Justification(reaction: "아쉽네요") {
                    nullify는 자식을 삭제하지 않고 관계만 해제(nil)합니다.
                }
            }
            
            @Choice(isCorrect: false) {
                @Relationship(deleteRule: .deny)
                
                @Justification(reaction: "아쉽네요") {
                    deny는 자식이 있으면 삭제를 막습니다.
                }
            }
        }
        
        @MultipleChoice {
            양방향 관계에서 inverse 파라미터의 역할은?
            
            @Choice(isCorrect: true) {
                반대쪽 관계 프로퍼티를 지정하여 자동 동기화
                
                @Justification(reaction: "정확합니다!") {
                    inverse는 양쪽 관계를 연결하여 한쪽 변경 시
                    반대쪽도 자동으로 업데이트되게 합니다.
                }
            }
            
            @Choice(isCorrect: false) {
                관계의 방향을 반대로 뒤집음
                
                @Justification(reaction: "아쉽네요") {
                    inverse는 방향을 뒤집는 게 아니라
                    양방향 동기화를 위해 반대쪽 프로퍼티를 지정합니다.
                }
            }
            
            @Choice(isCorrect: false) {
                관계 조회 시 역순으로 정렬
                
                @Justification(reaction: "아쉽네요") {
                    정렬과는 관계없습니다. 양방향 관계 동기화용입니다.
                }
            }
        }
        
        @MultipleChoice {
            1:N 관계에서 "N" 쪽의 타입은?
            
            @Choice(isCorrect: true) {
                [ModelType] (배열)
                
                @Justification(reaction: "정답!") {
                    1:N 관계에서 "N" 쪽은 여러 객체를 담아야 하므로
                    배열 타입을 사용합니다.
                }
            }
            
            @Choice(isCorrect: false) {
                Set<ModelType>
                
                @Justification(reaction: "아쉽네요") {
                    Core Data와 달리 SwiftData에서는 배열을 사용합니다.
                }
            }
            
            @Choice(isCorrect: false) {
                ModelType? (옵셔널)
                
                @Justification(reaction: "아쉽네요") {
                    옵셔널은 "1" 쪽(또는 0..1)에 적합합니다.
                }
            }
        }
    }
}
