@Tutorial(time: 15) {
    @Intro(title: "선택된 항목 로딩") {
        PhotosPickerItem에서 다양한 형식의 데이터를 로딩하는 
        고급 기법을 학습합니다.
    }
    
    @Section(title: "로딩 패턴 이해하기") {
        @ContentAndMedia {
            PhotosPickerItem의 데이터 로딩은 비동기입니다.
            효율적인 로딩을 위한 여러 패턴을 살펴봅니다.
        }
        
        @Steps {
            @Step {
                **기본 로딩 패턴**
                
                loadTransferable(type:)은 async throws 메서드입니다.
                Task 내에서 await로 호출합니다.
                
                @Code(name: "BasicLoading.swift", file: "06-basic-loading.swift")
            }
            
            @Step {
                **에러 처리 전략**
                
                로딩 실패에 대비한 에러 처리를 구현합니다.
                do-catch로 에러를 잡고 적절히 처리합니다.
                
                @Code(name: "ErrorHandling.swift", file: "06-error-handling.swift")
            }
            
            @Step {
                **취소 지원**
                
                Task.isCancelled를 확인해 취소된 작업을 빠르게 종료합니다.
                뷰가 사라지면 불필요한 로딩을 중단합니다.
                
                @Code(name: "CancellationSupport.swift", file: "06-cancellation-support.swift")
            }
        }
    }
    
    @Section(title: "병렬 로딩 구현") {
        @ContentAndMedia {
            여러 항목을 동시에 로딩하면 성능이 크게 향상됩니다.
            TaskGroup을 사용한 병렬 로딩을 구현합니다.
        }
        
        @Steps {
            @Step {
                **TaskGroup으로 병렬 로딩**
                
                withTaskGroup을 사용해 여러 이미지를 동시에 로딩합니다.
                순서를 유지하면서 병렬 처리가 가능합니다.
                
                @Code(name: "ParallelLoading.swift", file: "06-parallel-loading.swift")
            }
            
            @Step {
                **동시 로딩 개수 제한**
                
                너무 많은 동시 로딩은 메모리 문제를 일으킬 수 있습니다.
                동시 실행 개수를 제한하는 패턴을 구현합니다.
                
                @Code(name: "ConcurrencyLimit.swift", file: "06-concurrency-limit.swift")
            }
            
            @Step {
                **진행률 추적**
                
                전체 로딩 진행률을 계산해 사용자에게 표시합니다.
                @Published 프로퍼티로 UI에 바인딩합니다.
                
                @Code(name: "ProgressTracking.swift", file: "06-progress-tracking.swift")
            }
        }
    }
    
    @Section(title: "캐싱 전략") {
        @ContentAndMedia {
            로딩된 이미지를 캐시해 반복 로딩을 방지합니다.
            메모리와 디스크 캐시를 적절히 활용합니다.
        }
        
        @Steps {
            @Step {
                **메모리 캐시 구현**
                
                NSCache를 사용해 메모리 캐시를 구현합니다.
                자동으로 메모리 압박 시 캐시를 정리합니다.
                
                @Code(name: "MemoryCache.swift", file: "06-memory-cache.swift")
            }
            
            @Step {
                **캐시 키 설계**
                
                PhotosPickerItem의 itemIdentifier를 캐시 키로 사용합니다.
                동일한 사진은 다시 로딩하지 않습니다.
                
                @Code(name: "CacheKey.swift", file: "06-cache-key.swift")
            }
            
            @Step {
                **썸네일 vs 전체 이미지**
                
                목록에서는 썸네일을, 상세 화면에서는 전체 이미지를 로딩합니다.
                preferredItemEncoding으로 크기를 제어합니다.
                
                @Code(name: "ThumbnailVsFull.swift", file: "06-thumbnail-vs-full.swift")
            }
        }
    }
    
    @Section(title: "ViewModel 패턴") {
        @ContentAndMedia {
            이미지 로딩 로직을 ViewModel로 분리합니다.
            관찰 가능한 상태로 UI와 바인딩합니다.
        }
        
        @Steps {
            @Step {
                **GalleryViewModel 설계**
                
                선택, 로딩, 캐싱을 담당하는 ViewModel을 만듭니다.
                @Observable 매크로로 상태를 관찰 가능하게 합니다.
                
                @Code(name: "GalleryViewModel.swift", file: "06-gallery-view-model.swift")
            }
            
            @Step {
                **ImageItem 모델**
                
                로딩 상태와 이미지 데이터를 담는 모델을 정의합니다.
                Identifiable로 리스트에서 사용 가능하게 합니다.
                
                @Code(name: "ImageItem.swift", file: "06-image-item.swift")
            }
            
            @Step {
                **완성된 갤러리 화면**
                
                ViewModel을 활용한 완전한 갤러리 화면을 구현합니다.
                로딩 상태, 에러 처리, 캐싱이 모두 적용됩니다.
                
                @Code(name: "CompletedGallery.swift", file: "06-completed-gallery.swift")
            }
        }
    }
    
    @Assessments {
        @MultipleChoice {
            여러 이미지를 효율적으로 로딩하는 방법은?
            
            @Choice(isCorrect: true) {
                TaskGroup으로 병렬 로딩
                
                @Justification(reaction: "정답!") {
                    withTaskGroup을 사용하면 여러 이미지를 동시에 로딩해
                    전체 로딩 시간을 크게 줄일 수 있습니다.
                }
            }
            
            @Choice(isCorrect: false) {
                for 루프로 순차 로딩
                
                @Justification(reaction: "아쉽네요") {
                    순차 로딩은 간단하지만 느립니다.
                    병렬 로딩으로 성능을 크게 향상시킬 수 있습니다.
                }
            }
            
            @Choice(isCorrect: false) {
                DispatchQueue.global().async 사용
                
                @Justification(reaction: "아쉽네요") {
                    Swift Concurrency에서는 TaskGroup이 더 적합합니다.
                    구조화된 동시성으로 안전하게 병렬 처리할 수 있습니다.
                }
            }
        }
        
        @MultipleChoice {
            iOS에서 메모리 캐시에 적합한 클래스는?
            
            @Choice(isCorrect: true) {
                NSCache
                
                @Justification(reaction: "맞습니다!") {
                    NSCache는 메모리 압박 시 자동으로 항목을 제거합니다.
                    이미지 캐싱에 이상적입니다.
                }
            }
            
            @Choice(isCorrect: false) {
                Dictionary
                
                @Justification(reaction: "아쉽네요") {
                    Dictionary는 자동 메모리 관리가 없습니다.
                    메모리 압박 시 직접 정리해야 합니다.
                }
            }
            
            @Choice(isCorrect: false) {
                UserDefaults
                
                @Justification(reaction: "아쉽네요") {
                    UserDefaults는 디스크에 저장되며,
                    대용량 이미지 캐시에는 적합하지 않습니다.
                }
            }
        }
        
        @MultipleChoice {
            뷰가 사라질 때 진행 중인 로딩을 중단하려면?
            
            @Choice(isCorrect: true) {
                Task를 저장하고 onDisappear에서 cancel() 호출
                
                @Justification(reaction: "정확합니다!") {
                    Task를 @State에 저장하고 뷰가 사라질 때 
                    cancel()을 호출하면 로딩이 취소됩니다.
                }
            }
            
            @Choice(isCorrect: false) {
                Task는 자동으로 취소됨
                
                @Justification(reaction: "아쉽네요") {
                    Task는 자동으로 취소되지 않습니다.
                    명시적으로 cancel()을 호출해야 합니다.
                }
            }
            
            @Choice(isCorrect: false) {
                취소 불가능
                
                @Justification(reaction: "아쉽네요") {
                    Task는 cancel() 메서드를 통해 취소 요청이 가능합니다.
                    작업 내에서 Task.isCancelled를 확인해 처리합니다.
                }
            }
        }
    }
}
