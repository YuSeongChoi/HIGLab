@Tutorial(time: 15) {
    @Intro(title: "CLLocationManager 설정") {
        CoreLocation의 핵심인 CLLocationManager를 설정하고,
        위치 권한을 요청하는 방법을 배웁니다.
    }
    
    @Section(title: "CLLocationManager 기초") {
        @ContentAndMedia {
            `CLLocationManager`는 모든 위치 서비스의 진입점입니다.
            위치 업데이트 요청, 권한 관리, 정확도 설정 등
            모든 작업이 이 객체를 통해 이루어집니다.
        }
        
        @Steps {
            @Step {
                **LocationManager 클래스 생성**
                
                ObservableObject를 채택하여 SwiftUI와 연동되는
                LocationManager 클래스를 만듭니다.
                
                @Code(name: "LocationManager.swift", file: "02-location-manager-base.swift")
            }
            
            @Step {
                **CLLocationManagerDelegate 구현**
                
                위치 업데이트와 권한 변경을 받기 위해
                Delegate 패턴을 사용합니다.
                
                @Code(name: "LocationManager.swift", file: "02-delegate-setup.swift")
            }
            
            @Step {
                **NSObject 상속과 Delegate 연결**
                
                CLLocationManagerDelegate는 Objective-C 프로토콜이므로
                NSObject를 상속해야 합니다.
                
                @Code(name: "LocationManager.swift", file: "02-nsobject.swift")
            }
        }
    }
    
    @Section(title: "권한 요청 구현") {
        @ContentAndMedia {
            위치 권한은 단계적으로 요청하는 것이 좋습니다.
            먼저 "When In Use"를 요청하고, 
            필요할 때 "Always"로 업그레이드합니다.
        }
        
        @Steps {
            @Step {
                **권한 상태 추적**
                
                `authorizationStatus`를 @Published 프로퍼티로 노출하여
                UI에서 권한 상태에 따라 다른 화면을 보여줍니다.
                
                @Code(name: "LocationManager.swift", file: "02-auth-tracking.swift")
            }
            
            @Step {
                **When In Use 권한 요청**
                
                `requestWhenInUseAuthorization()`을 호출하면
                시스템이 권한 요청 Alert를 표시합니다.
                
                @Code(name: "LocationManager.swift", file: "02-when-in-use.swift")
            }
            
            @Step {
                **Always 권한으로 업그레이드**
                
                "When In Use" 권한을 받은 후에만 
                "Always" 권한을 요청할 수 있습니다.
                iOS 13부터 이 순서가 강제됩니다.
                
                @Code(name: "LocationManager.swift", file: "02-always-auth.swift")
            }
            
            @Step {
                **권한 변경 처리**
                
                `locationManagerDidChangeAuthorization` 델리게이트 메서드에서
                권한 변경을 감지하고 적절히 대응합니다.
                
                @Code(name: "LocationManager.swift", file: "02-auth-change.swift")
            }
        }
    }
    
    @Section(title: "SwiftUI 연동") {
        @ContentAndMedia {
            LocationManager를 SwiftUI 뷰에서 사용하여
            권한 상태를 표시하고 권한을 요청하는 UI를 만듭니다.
        }
        
        @Steps {
            @Step {
                **Environment Object로 공유**
                
                LocationManager를 앱 전체에서 공유하기 위해
                @StateObject와 environmentObject를 사용합니다.
                
                @Code(name: "RunningTrackerApp.swift", file: "02-app-environment.swift")
            }
            
            @Step {
                **권한 요청 뷰 만들기**
                
                사용자에게 위치 권한이 왜 필요한지 설명하고
                권한을 요청하는 온보딩 뷰를 만듭니다.
                
                @Code(name: "PermissionView.swift", file: "02-permission-view.swift")
            }
            
            @Step {
                **권한 상태에 따른 화면 전환**
                
                권한 상태에 따라 온보딩 화면 또는 메인 화면을
                보여주도록 ContentView를 수정합니다.
                
                @Code(name: "ContentView.swift", file: "02-content-view.swift")
            }
        }
    }
    
    @Assessments {
        @MultipleChoice {
            CLLocationManagerDelegate를 사용하려면 어떤 클래스를 상속해야 하나요?
            
            @Choice(isCorrect: true) {
                NSObject
                
                @Justification(reaction: "정답!") {
                    CLLocationManagerDelegate는 Objective-C 프로토콜이므로
                    NSObject를 상속해야 delegate 메서드가 호출됩니다.
                }
            }
            
            @Choice(isCorrect: false) {
                UIViewController
                
                @Justification(reaction: "아쉽네요") {
                    UIViewController도 NSObject를 상속하므로 동작하지만,
                    SwiftUI에서는 NSObject만 상속하는 것이 적절합니다.
                }
            }
            
            @Choice(isCorrect: false) {
                상속 없이 사용 가능
                
                @Justification(reaction: "아쉽네요") {
                    Swift 클래스가 Objective-C delegate를 구현하려면
                    반드시 NSObject를 상속해야 합니다.
                }
            }
        }
        
        @MultipleChoice {
            iOS 13 이후 "Always" 권한을 요청하는 올바른 방법은?
            
            @Choice(isCorrect: true) {
                먼저 "When In Use"를 받은 후 "Always"를 요청
                
                @Justification(reaction: "정확합니다!") {
                    iOS 13부터 "Always" 권한은 임시 권한으로 시작하며,
                    사용자가 나중에 설정에서 최종 승인해야 합니다.
                }
            }
            
            @Choice(isCorrect: false) {
                처음부터 "Always"를 요청
                
                @Justification(reaction: "아쉽네요") {
                    iOS 13부터 직접 "Always"를 요청해도
                    "When In Use"가 먼저 부여됩니다.
                }
            }
            
            @Choice(isCorrect: false) {
                두 권한을 동시에 요청
                
                @Justification(reaction: "아쉽네요") {
                    권한은 단계적으로 요청해야 합니다.
                    동시 요청은 불가능합니다.
                }
            }
        }
        
        @MultipleChoice {
            권한 변경을 감지하는 델리게이트 메서드는?
            
            @Choice(isCorrect: true) {
                locationManagerDidChangeAuthorization(_:)
                
                @Justification(reaction: "정답!") {
                    iOS 14부터 이 메서드가 권한 변경을 알려줍니다.
                    이전의 locationManager(_:didChangeAuthorization:)는 deprecated입니다.
                }
            }
            
            @Choice(isCorrect: false) {
                locationManager(_:didUpdateLocations:)
                
                @Justification(reaction: "아쉽네요") {
                    이 메서드는 위치 업데이트를 받을 때 호출됩니다.
                    권한 변경과는 관련이 없습니다.
                }
            }
            
            @Choice(isCorrect: false) {
                authorizationStatusDidChange()
                
                @Justification(reaction: "아쉽네요") {
                    이런 이름의 메서드는 존재하지 않습니다.
                    locationManagerDidChangeAuthorization을 사용하세요.
                }
            }
        }
    }
}
