@Tutorial(time: 20) {
    @Intro(title: "배치 처리") {
        여러 이미지를 효율적으로 처리하는 배치 작업 방법을 학습합니다.
        
        ExtensibleImage의 배치 API로 대량의 이미지를 최적화된 방식으로 처리합니다.
        
        @Image(source: "batch-processing-hero.png", alt: "배치 처리 예시")
    }
    
    @Section(title: "배치 작업 기초") {
        @ContentAndMedia {
            `ExtensibleImage.BatchProcessor`는 여러 이미지에 동일한 작업을 적용할 때 리소스를 효율적으로 활용합니다.
            
            Neural Engine 웜업을 재사용하고 메모리 할당을 최적화합니다.
        }
        
        @Steps {
            @Step {
                BatchProcessor를 생성하고 처리할 이미지 목록을 준비합니다.
                
                @Code(name: "BatchBasics.swift", file: "08-batch-01.swift")
            }
            
            @Step {
                처리할 작업을 정의하고 배치에 추가합니다.
                
                @Code(name: "BatchBasics.swift", file: "08-batch-02.swift")
            }
            
            @Step {
                배치를 실행하고 각 결과를 처리합니다.
                
                @Code(name: "BatchBasics.swift", file: "08-batch-03.swift")
            }
        }
    }
    
    @Section(title: "진행 상황 추적") {
        @ContentAndMedia {
            대량 처리 시 사용자에게 진행 상황을 표시하는 것이 중요합니다.
        }
        
        @Steps {
            @Step {
                진행률을 추적하는 델리게이트를 구현합니다.
                
                @Code(name: "Progress.swift", file: "08-batch-04.swift")
            }
            
            @Step {
                SwiftUI에서 ProgressView와 연동합니다.
                
                @Code(name: "Progress.swift", file: "08-batch-05.swift")
            }
            
            @Step {
                개별 이미지의 상태를 목록으로 표시합니다.
                
                @Code(name: "Progress.swift", file: "08-batch-06.swift")
            }
        }
    }
    
    @Section(title: "오류 처리와 재시도") {
        @ContentAndMedia {
            배치 처리 중 일부 이미지가 실패해도 전체 작업을 중단하지 않고 계속 진행합니다.
        }
        
        @Steps {
            @Step {
                오류 처리 전략을 설정합니다.
                
                @Code(name: "ErrorHandling.swift", file: "08-batch-07.swift")
            }
            
            @Step {
                실패한 항목만 재시도하는 로직을 구현합니다.
                
                @Code(name: "ErrorHandling.swift", file: "08-batch-08.swift")
            }
        }
    }
    
    @Section(title: "동시성 제어") {
        @ContentAndMedia {
            동시에 처리할 이미지 수를 조절하여 메모리 사용량과 처리 속도의 균형을 맞춥니다.
        }
        
        @Steps {
            @Step {
                동시성 수준을 설정합니다.
                
                @Code(name: "Concurrency.swift", file: "08-batch-09.swift")
            }
            
            @Step {
                기기 성능에 따라 동적으로 동시성을 조절합니다.
                
                @Code(name: "Concurrency.swift", file: "08-batch-10.swift")
            }
            
            @Step {
                취소 가능한 배치 작업을 구현합니다.
                
                @Code(name: "Concurrency.swift", file: "08-batch-11.swift")
            }
        }
    }
    
    @Section(title: "파이프라인 구성") {
        @ContentAndMedia {
            여러 작업을 연결하여 복잡한 처리 파이프라인을 구성합니다.
        }
        
        @Steps {
            @Step {
                여러 작업을 순차적으로 연결합니다.
                
                @Code(name: "Pipeline.swift", file: "08-batch-12.swift")
            }
            
            @Step {
                조건부 분기를 포함한 파이프라인을 구성합니다.
                
                @Code(name: "Pipeline.swift", file: "08-batch-13.swift")
            }
        }
    }
    
    @Assessments {
        @MultipleChoice {
            100장의 고해상도 이미지를 배치 처리할 때 메모리 부족을 방지하려면?
            
            @Choice(isCorrect: false) {
                .concurrency(.unlimited)로 최대한 빠르게 처리한다
                
                @Justification(reaction: "다시 생각해보세요.") {
                    무제한 동시성은 메모리를 급격히 소모하여 오히려 크래시를 유발할 수 있습니다.
                }
            }
            
            @Choice(isCorrect: true) {
                .concurrency(.limited(4))와 .memoryPolicy(.conservative)를 함께 사용한다
                
                @Justification(reaction: "정답입니다!") {
                    제한된 동시성과 보수적인 메모리 정책으로 안정적인 처리가 가능합니다.
                }
            }
            
            @Choice(isCorrect: false) {
                모든 이미지를 미리 메모리에 로드한다
                
                @Justification(reaction: "다시 생각해보세요.") {
                    이는 메모리 부족의 원인이 됩니다. 지연 로딩을 사용해야 합니다.
                }
            }
        }
    }
}
