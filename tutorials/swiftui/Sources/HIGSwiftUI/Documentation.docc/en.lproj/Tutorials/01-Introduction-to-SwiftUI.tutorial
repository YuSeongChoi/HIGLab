@Tutorial(time: 15) {
    @Intro(title: "Introduction to SwiftUI & Declarative UI Philosophy") {
        Understand the background of SwiftUI's creation and core concepts of declarative UI.
        Learn the differences from UIKit and why SwiftUI is the future.
    }
    
    @Section(title: "Why SwiftUI?") {
        @ContentAndMedia {
            At WWDC 2019, Apple announced SwiftUI, opening 
            a new era in iOS development.
            
            Traditional UIKit was **imperative**.
            "Create a button â†’ change color â†’ set position"
            
            SwiftUI is **declarative**.
            "There should be a button that looks like this here"
            
            Code is UI, and UI is code.
        }
        
        @Steps {
            @Step {
                **Imperative vs Declarative â€” What's Different?**
                
                Imperative explains "How".
                
                To create a label in UIKit:
                1. Create UILabel instance
                2. Set text
                3. Set font
                4. addSubview to view
                5. Set constraints
                
                @Code(name: "ImperativeExample.swift", file: "01-imperative.swift")
            }
            
            @Step {
                Declarative explains **"What"**.
                
                To create the same label in SwiftUI:
                Just declare Text("Hello") and you're done!
                
                The system renders it optimally on its own.
                
                @Code(name: "DeclarativeExample.swift", file: "01-declarative.swift")
            }
            
            @Step {
                **The Revolution of State-Based UI**
                
                SwiftUI's biggest advantage is that **when state changes,
                UI updates automatically**.
                
                No need to manually call reloadData()
                or setNeedsLayout().
                
                @Code(name: "StateBasedUI.swift", file: "01-state-based.swift")
            }
        }
    }
    
    @Section(title: "Core Principles of SwiftUI") {
        @ContentAndMedia {
            Apple established four principles when designing SwiftUI.
            Understanding these principles helps you better utilize SwiftUI.
        }
        
        @Steps {
            @Step {
                **1. Declarative Syntax**
                
                You just "describe" the UI.
                The framework handles complex logic.
                
                As a result, code becomes shorter and more readable.
                
                @Code(name: "Principle1.swift", file: "01-principle-declarative.swift")
            }
            
            @Step {
                **2. Composability**
                
                Combine small views to make larger views.
                It's like stacking Lego blocks.
                
                In ChefBook, create RecipeCard,
                put it in a List, wrap with NavigationStack.
                
                @Code(name: "Principle2.swift", file: "01-principle-compose.swift")
            }
            
            @Step {
                **3. Automatic Synchronization**
                
                Data and UI are always in sync.
                Tools like @State, @Binding, @Observable
                maintain a "Single Source of Truth".
                
                @Code(name: "Principle3.swift", file: "01-principle-sync.swift")
            }
            
            @Step {
                **4. Cross-Platform**
                
                One codebase for iOS, macOS, watchOS, tvOS, and visionOS!
                SwiftUI automatically handles platform differences.
                
                Platform-specific optimization is also possible.
                
                @Code(name: "Principle4.swift", file: "01-principle-platform.swift")
            }
        }
    }
    
    @Section(title: "Starting the ChefBook Project") {
        @ContentAndMedia {
            Now let's start our project "ChefBook"!
            
            ChefBook is an app where users can save favorite recipes
            and follow step-by-step instructions while cooking.
            
            Let's open Xcode and create a new project.
        }
        
        @Steps {
            @Step {
                Select **File â†’ New â†’ Project** in Xcode.
                Choose **App** as the template.
                
                - Product Name: `ChefBook`
                - Interface: `SwiftUI`
                - Language: `Swift`
                
                @Code(name: "ChefBookApp.swift", file: "01-project-setup.swift")
            }
            
            @Step {
                Open the created `ContentView.swift` and
                you'll see the default "Hello, world!" screen.
                
                Let's turn this into ChefBook's first screen!
                
                @Code(name: "ContentView.swift", file: "01-first-view.swift")
            }
            
            @Step {
                **Real-time verification with Xcode Preview!**
                
                One of SwiftUI's powerful features is live preview.
                You can see results immediately as you modify code.
                
                If Canvas isn't visible, enable **Editor â†’ Canvas**.
                
                @Code(name: "ContentView.swift", file: "01-preview.swift")
            }
        }
    }
    
    @Assessments {
        @MultipleChoice {
            What does SwiftUI's "Declarative" approach mean?
            
            @Choice(isCorrect: true) {
                A way of describing "how the UI should look"
                
                @Justification(reaction: "Correct! ðŸŽ‰") {
                    The declarative approach focuses on "What".
                    "How" is handled by the framework.
                }
            }
            
            @Choice(isCorrect: false) {
                A way of commanding UI step by step
                
                @Justification(reaction: "Not quite ðŸ˜…") {
                    That's the Imperative approach.
                    UIKit is a typical example.
                }
            }
            
            @Choice(isCorrect: false) {
                A way of creating UI by drag-and-drop without code
                
                @Justification(reaction: "Not quite ðŸ˜…") {
                    SwiftUI also requires writing code.
                    However, that code "describes" the UI's "state".
                }
            }
        }
        
        @MultipleChoice {
            What happens when @State changes in SwiftUI?
            
            @Choice(isCorrect: true) {
                The view automatically re-renders
                
                @Justification(reaction: "Perfect! âœ¨") {
                    This is a core principle of SwiftUI.
                    When state changes, UI automatically synchronizes.
                }
            }
            
            @Choice(isCorrect: false) {
                You need to call reloadData()
                
                @Justification(reaction: "Not quite") {
                    That's the UIKit way.
                    SwiftUI handles it automatically.
                }
            }
            
            @Choice(isCorrect: false) {
                Nothing happens
                
                @Justification(reaction: "Not quite") {
                    SwiftUI detects state changes and
                    automatically updates the UI.
                }
            }
        }
    }
}
