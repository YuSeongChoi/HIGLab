@Tutorial(time: 35) {
    @Intro(title: "게임 햅틱 피드백") {
        게임에 적합한 인터랙티브 햅틱 시스템을 구축하고
        몰입감 있는 게임 경험을 만드는 방법을 배웁니다.
        
        @Image(source: "game-haptics.png", alt: "게임 햅틱 피드백")
    }
    
    @Section(title: "게임 햅틱의 특수 요구사항") {
        @ContentAndMedia {
            게임 햅틱은 일반 앱과 다른 요구사항이 있습니다.
            
            - **즉각적인 응답**: 지연은 몰입감을 깨뜨림
            - **다양한 강도**: 약한 터치부터 강한 충돌까지
            - **지속적 피드백**: 엔진 진동, 이동 느낌 등
            - **동시 재생**: 여러 이벤트가 겹칠 수 있음
            - **배터리 고려**: 오래 플레이해도 부담 없도록
        }
        
        @Steps {
            @Step {
                게임에 최적화된 햅틱 매니저를 설정합니다.
                auto-shutdown을 비활성화하고 즉시 응답을 보장합니다.
                
                @Code(name: "GameHapticManager.swift", file: "08-01-game-manager.swift")
            }
            
            @Step {
                자주 사용하는 패턴을 프리로드하여 
                첫 번째 재생의 지연을 방지합니다.
                
                @Code(name: "GameHapticManager.swift", file: "08-02-preload-patterns.swift")
            }
        }
    }
    
    @Section(title: "충돌과 물리 피드백") {
        @ContentAndMedia {
            게임에서 가장 흔한 햅틱은 충돌 피드백입니다.
            충돌 강도, 재질, 방향에 따라 다른 느낌을 제공합니다.
            
            물리 엔진의 충돌 데이터를 햅틱 파라미터로 변환하는 
            시스템을 구축합니다.
        }
        
        @Steps {
            @Step {
                충돌 강도에 따른 햅틱을 구현합니다.
                물리 엔진의 impulse 값을 intensity로 매핑합니다.
                
                @Code(name: "CollisionHaptics.swift", file: "08-03-collision-intensity.swift")
            }
            
            @Step {
                재질에 따른 다른 촉감을 표현합니다.
                금속은 날카롭게, 고무는 부드럽게 느껴집니다.
                
                @Code(name: "CollisionHaptics.swift", file: "08-04-material-haptics.swift")
            }
            
            @Step {
                연속적인 충돌을 자연스럽게 처리합니다.
                총알 연사, 드리블 등의 패턴을 구현합니다.
                
                @Code(name: "RapidCollisions.swift", file: "08-05-rapid-collisions.swift")
            }
        }
    }
    
    @Section(title: "환경 피드백") {
        @ContentAndMedia {
            캐릭터가 경험하는 환경을 햅틱으로 전달합니다.
            
            - 엔진/모터 진동
            - 걷기/달리기 발걸음
            - 물속/진흙 저항감
            - 바람/폭발 충격
        }
        
        @Steps {
            @Step {
                차량 엔진 진동을 시뮬레이션합니다.
                RPM에 따라 진동 주기와 강도가 변합니다.
                
                @Code(name: "EngineHaptic.swift", file: "08-06-engine-vibration.swift")
            }
            
            @Step {
                캐릭터 발걸음에 맞춘 햅틱을 추가합니다.
                지면 재질과 속도에 따라 달라집니다.
                
                @Code(name: "FootstepHaptic.swift", file: "08-07-footsteps.swift")
            }
            
            @Step {
                폭발과 충격파를 거리 기반으로 표현합니다.
                가까울수록 강하고, 멀수록 약해집니다.
                
                @Code(name: "ExplosionHaptic.swift", file: "08-08-explosion.swift")
            }
        }
    }
    
    @Section(title: "UI 게임 피드백") {
        @ContentAndMedia {
            게임 UI 인터랙션에도 햅틱을 활용합니다.
            
            - 메뉴 네비게이션
            - 아이템 획득/사용
            - 레벨업/업적 달성
            - 카운트다운/타이머
        }
        
        @Steps {
            @Step {
                아이템 획득의 만족스러운 피드백을 디자인합니다.
                희귀도에 따라 다른 패턴을 적용합니다.
                
                @Code(name: "ItemHaptics.swift", file: "08-09-item-collect.swift")
            }
            
            @Step {
                레벨업 세레모니 햅틱을 만듭니다.
                점점 고조되는 빌드업과 폭발적인 피크를 조합합니다.
                
                @Code(name: "LevelUpHaptic.swift", file: "08-10-level-up.swift")
            }
            
            @Step {
                타이머 카운트다운을 햅틱으로 표현합니다.
                남은 시간이 줄어들수록 긴박감을 높입니다.
                
                @Code(name: "CountdownHaptic.swift", file: "08-11-countdown.swift")
            }
        }
    }
    
    @Section(title: "햅틱 최적화") {
        @ContentAndMedia {
            게임에서 햅틱은 빈번하게 호출됩니다.
            성능과 배터리를 위한 최적화 전략을 알아봅니다.
        }
        
        @Steps {
            @Step {
                쓰로틀링으로 과도한 햅틱 호출을 방지합니다.
                연속 재생 시 최소 간격을 유지합니다.
                
                @Code(name: "HapticThrottling.swift", file: "08-12-throttling.swift")
            }
            
            @Step {
                우선순위 시스템으로 중요한 햅틱을 보장합니다.
                낮은 우선순위 햅틱은 상황에 따라 생략됩니다.
                
                @Code(name: "HapticPriority.swift", file: "08-13-priority.swift")
            }
            
            @Step {
                게임 상태에 따른 햅틱 강도 조절을 구현합니다.
                배터리 부족 시 자동으로 강도를 낮춥니다.
                
                @Code(name: "AdaptiveHaptics.swift", file: "08-14-adaptive.swift")
            }
        }
    }
    
    @Assessments {
        @MultipleChoice {
            게임에서 auto-shutdown을 비활성화하는 이유는?
            
            @Choice(isCorrect: true) {
                엔진 재시작 없이 즉각적인 햅틱 응답을 보장하기 위해
                
                @Justification(reaction: "정확합니다! 🎮") {
                    게임에서 밀리초 단위의 지연도 
                    몰입감을 해칠 수 있습니다.
                }
            }
            
            @Choice(isCorrect: false) {
                더 강한 햅틱을 만들기 위해
                
                @Justification(reaction: "관련이 없습니다.") {
                    auto-shutdown은 응답 속도와 관련 있지
                    햅틱 강도와는 무관합니다.
                }
            }
            
            @Choice(isCorrect: false) {
                배터리를 절약하기 위해
                
                @Justification(reaction: "오히려 반대입니다.") {
                    auto-shutdown을 끄면 배터리 소모가 증가합니다.
                    게임 플레이 중 필요한 트레이드오프입니다.
                }
            }
        }
        
        @MultipleChoice {
            충돌 강도를 햅틱 intensity로 매핑할 때 
            권장되는 방식은?
            
            @Choice(isCorrect: false) {
                물리 엔진 값을 그대로 사용한다
                
                @Justification(reaction: "위험합니다.") {
                    물리 엔진 값의 범위가 0.0~1.0이 아닐 수 있고,
                    극단적인 값이 나올 수 있습니다.
                }
            }
            
            @Choice(isCorrect: true) {
                최소/최대 범위를 정하고 정규화하여 매핑한다
                
                @Justification(reaction: "좋은 접근입니다! 📊") {
                    일관된 경험을 위해 범위를 제한하고
                    부드럽게 매핑하는 것이 좋습니다.
                }
            }
            
            @Choice(isCorrect: false) {
                항상 최대 강도를 사용한다
                
                @Justification(reaction: "피로감을 유발합니다.") {
                    강도 변화가 없으면 의미 전달이 어렵고
                    사용자가 금방 지칩니다.
                }
            }
        }
    }
}
