@Tutorial(time: 20) {
    @Intro(title: "UDP 통신") {
        빠른 데이터 전송이 필요한 상황에서 
        UDP를 활용하는 방법을 배웁니다.
        
        @Image(source: "udp-communication.png", alt: "UDP 통신 다이어그램")
    }
    
    @Section(title: "UDP의 특징 이해하기") {
        @ContentAndMedia {
            UDP(User Datagram Protocol)는 
            비연결형 프로토콜입니다.
            
            - **비연결**: handshake 없이 즉시 전송
            - **빠른 속도**: 오버헤드가 적음
            - **순서 미보장**: 패킷 도착 순서가 다를 수 있음
            - **손실 가능**: 패킷이 유실될 수 있음
            
            @Image(source: "udp-vs-tcp.png", alt: "UDP와 TCP 비교")
        }
        
        @Steps {
            @Step {
                UDP가 적합한 사용 사례를 이해합니다.
                
                - 실시간 게임 (위치, 상태 업데이트)
                - VoIP / 영상 통화
                - DNS 조회
                - IoT 센서 데이터
                
                @Code(name: "UDPUseCases.swift", file: "03-01-udp-usecases.swift")
            }
            
            @Step {
                UDP 파라미터를 설정합니다.
                `.udp`는 기본 UDP 설정을 제공합니다.
                
                @Code(name: "UDPParameters.swift", file: "03-02-udp-params.swift")
            }
        }
    }
    
    @Section(title: "UDP 메시지 전송") {
        @ContentAndMedia {
            UDP에서는 각 send()가 하나의 데이터그램이 됩니다.
            데이터그램의 최대 크기는 일반적으로 65,507 바이트이지만,
            MTU(Maximum Transmission Unit)를 고려해야 합니다.
        }
        
        @Steps {
            @Step {
                UDP 연결을 생성합니다.
                TCP와 달리 연결 수립 과정이 없습니다.
                
                @Code(name: "UDPConnection.swift", file: "03-03-udp-connection.swift")
            }
            
            @Step {
                데이터그램을 전송합니다.
                각 send 호출이 독립적인 패킷이 됩니다.
                
                @Code(name: "UDPSend.swift", file: "03-04-udp-send.swift")
            }
            
            @Step {
                여러 메시지를 빠르게 전송합니다.
                TCP와 달리 각 메시지가 독립적으로 전달됩니다.
                
                @Code(name: "UDPBurst.swift", file: "03-05-udp-burst.swift")
            }
        }
    }
    
    @Section(title: "UDP 메시지 수신") {
        @ContentAndMedia {
            UDP 수신은 `receiveMessage()`를 사용합니다.
            각 호출이 하나의 데이터그램을 반환합니다.
        }
        
        @Steps {
            @Step {
                데이터그램을 수신합니다.
                context에서 발신자 정보를 확인할 수 있습니다.
                
                @Code(name: "UDPReceive.swift", file: "03-06-udp-receive.swift")
            }
            
            @Step {
                연속 수신을 위한 루프를 구성합니다.
                수신 후 다시 receive를 호출합니다.
                
                @Code(name: "UDPReceiveLoop.swift", file: "03-07-udp-receive-loop.swift")
            }
            
            @Step {
                타임아웃을 구현합니다.
                UDP는 응답 보장이 없으므로 타임아웃 처리가 중요합니다.
                
                @Code(name: "UDPTimeout.swift", file: "03-08-udp-timeout.swift")
            }
        }
    }
    
    @Section(title: "게임 상태 동기화 예제") {
        @ContentAndMedia {
            실시간 게임에서 플레이어 위치를 동기화하는 
            간단한 예제를 만들어봅니다.
            
            UDP의 빠른 속도를 활용하되,
            손실에 대비한 로직을 추가합니다.
        }
        
        @Steps {
            @Step {
                플레이어 상태를 나타내는 구조체를 정의합니다.
                시퀀스 번호로 순서를 관리합니다.
                
                @Code(name: "PlayerState.swift", file: "03-09-player-state.swift")
            }
            
            @Step {
                상태를 직렬화해서 전송합니다.
                Codable을 활용하면 편리합니다.
                
                @Code(name: "StateSend.swift", file: "03-10-state-send.swift")
            }
            
            @Step {
                수신 측에서 시퀀스 번호를 확인합니다.
                오래된 패킷은 무시하고 최신 상태만 적용합니다.
                
                @Code(name: "StateReceive.swift", file: "03-11-state-receive.swift")
            }
        }
    }
    
    @Assessments {
        @MultipleChoice {
            UDP에서 시퀀스 번호를 사용하는 이유는?
            
            @Choice(isCorrect: false) {
                패킷 손실을 자동으로 복구하기 위해
                
                @Justification(reaction: "다시 생각해보세요.") {
                    UDP는 패킷 재전송을 하지 않습니다.
                    시퀀스 번호는 순서 판단에 사용됩니다.
                }
            }
            
            @Choice(isCorrect: true) {
                늦게 도착한 오래된 패킷을 무시하기 위해
                
                @Justification(reaction: "정확합니다! 🎯") {
                    UDP는 순서를 보장하지 않으므로
                    시퀀스 번호로 최신 데이터만 사용할 수 있습니다.
                }
            }
            
            @Choice(isCorrect: false) {
                암호화를 위한 키로 사용하기 위해
                
                @Justification(reaction: "아쉽습니다.") {
                    시퀀스 번호는 암호화와 관련이 없습니다.
                    보안은 DTLS로 처리합니다.
                }
            }
        }
        
        @MultipleChoice {
            UDP가 TCP보다 적합한 상황은?
            
            @Choice(isCorrect: false) {
                파일 다운로드
                
                @Justification(reaction: "틀렸습니다.") {
                    파일 다운로드는 모든 데이터가 정확히 전달되어야 하므로
                    TCP가 적합합니다.
                }
            }
            
            @Choice(isCorrect: false) {
                채팅 메시지 전송
                
                @Justification(reaction: "다시 생각해보세요.") {
                    채팅 메시지는 손실되면 안 되므로
                    일반적으로 TCP를 사용합니다.
                }
            }
            
            @Choice(isCorrect: true) {
                실시간 게임에서 캐릭터 위치 업데이트
                
                @Justification(reaction: "맞습니다! ✨") {
                    실시간 게임에서는 최신 위치가 중요하고,
                    약간의 패킷 손실보다 지연이 더 치명적입니다.
                }
            }
        }
    }
}
