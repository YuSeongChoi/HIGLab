@Tutorial(time: 20) {
    @Intro(title: "TCP 연결") {
        NWConnection으로 안정적인 TCP 연결을 생성하고 
        데이터를 송수신하는 방법을 배웁니다.
        
        @Image(source: "tcp-connection.png", alt: "TCP 연결 다이어그램")
    }
    
    @Section(title: "TCP 연결 생성하기") {
        @ContentAndMedia {
            TCP(Transmission Control Protocol)는 신뢰성 있는 
            데이터 전송을 보장하는 프로토콜입니다.
            
            - **연결 지향**: 3-way handshake로 연결 수립
            - **순서 보장**: 패킷이 순서대로 도착
            - **오류 복구**: 손실된 패킷 자동 재전송
            - **흐름 제어**: 수신자 버퍼 오버플로우 방지
            
            @Image(source: "tcp-handshake.png", alt: "TCP 3-way handshake")
        }
        
        @Steps {
            @Step {
                TCP 연결을 위한 NWParameters를 설정합니다.
                `.tcp`는 기본 TCP 파라미터를 제공합니다.
                
                @Code(name: "TCPParameters.swift", file: "02-01-tcp-params.swift")
            }
            
            @Step {
                NWConnection을 생성하고 상태 핸들러를 등록합니다.
                연결 상태 변화를 모니터링할 수 있습니다.
                
                @Code(name: "TCPConnection.swift", file: "02-02-tcp-connection.swift")
            }
            
            @Step {
                연결을 시작하고 DispatchQueue를 지정합니다.
                모든 콜백은 지정된 큐에서 실행됩니다.
                
                @Code(name: "TCPStart.swift", file: "02-03-tcp-start.swift")
            }
        }
    }
    
    @Section(title: "데이터 송신하기") {
        @ContentAndMedia {
            TCP 연결이 수립되면 `send()` 메서드로 데이터를 전송합니다.
            
            Network 프레임워크는 Data, DispatchData, 
            커스텀 프로토콜 메시지 등 다양한 형태를 지원합니다.
        }
        
        @Steps {
            @Step {
                문자열을 Data로 변환해서 전송합니다.
                UTF-8 인코딩을 사용하는 것이 일반적입니다.
                
                @Code(name: "SendString.swift", file: "02-04-send-string.swift")
            }
            
            @Step {
                `contentContext`로 메시지의 의미를 지정할 수 있습니다.
                `.finalMessage`는 이 메시지 후 연결을 종료한다는 의미입니다.
                
                @Code(name: "SendContext.swift", file: "02-05-send-context.swift")
            }
            
            @Step {
                전송 완료 콜백에서 에러를 처리합니다.
                네트워크 오류 시 적절한 재시도 로직이 필요합니다.
                
                @Code(name: "SendCompletion.swift", file: "02-06-send-completion.swift")
            }
        }
    }
    
    @Section(title: "데이터 수신하기") {
        @ContentAndMedia {
            `receive()` 메서드로 상대방이 보낸 데이터를 수신합니다.
            
            두 가지 수신 방식이 있습니다:
            - `receive(minimumIncompleteLength:maximumLength:)`: 바이트 단위
            - `receiveMessage()`: 메시지 단위 (프레이밍 사용 시)
        }
        
        @Steps {
            @Step {
                바이트 단위로 데이터를 수신합니다.
                minimum은 최소 대기량, maximum은 최대 수신량입니다.
                
                @Code(name: "ReceiveBytes.swift", file: "02-07-receive-bytes.swift")
            }
            
            @Step {
                연속적인 수신을 위해 재귀적으로 receive를 호출합니다.
                연결이 유지되는 동안 계속 데이터를 받을 수 있습니다.
                
                @Code(name: "ReceiveLoop.swift", file: "02-08-receive-loop.swift")
            }
            
            @Step {
                수신된 데이터를 문자열로 변환합니다.
                상대방과 같은 인코딩을 사용해야 합니다.
                
                @Code(name: "ReceiveString.swift", file: "02-09-receive-string.swift")
            }
        }
    }
    
    @Section(title: "P2P 채팅 클라이언트") {
        @ContentAndMedia {
            지금까지 배운 내용을 종합해서 
            간단한 채팅 클라이언트를 만들어봅니다.
            
            연결, 송신, 수신을 하나의 클래스로 캡슐화합니다.
        }
        
        @Steps {
            @Step {
                ChatClient 클래스의 기본 구조를 만듭니다.
                NWConnection을 프로퍼티로 관리합니다.
                
                @Code(name: "ChatClient.swift", file: "02-10-chat-client.swift")
            }
            
            @Step {
                연결 상태에 따른 UI 업데이트를 위해 
                Combine이나 콜백을 활용합니다.
                
                @Code(name: "ChatClientCallback.swift", file: "02-11-chat-callback.swift")
            }
            
            @Step {
                연결 종료 시 리소스를 정리합니다.
                `cancel()` 호출 후 connection을 nil로 설정합니다.
                
                @Code(name: "ChatClientDisconnect.swift", file: "02-12-chat-disconnect.swift")
            }
        }
    }
    
    @Assessments {
        @MultipleChoice {
            NWConnection의 send 메서드에서 isComplete 파라미터의 역할은?
            
            @Choice(isCorrect: false) {
                데이터 전송이 완료되었음을 알린다.
                
                @Justification(reaction: "다시 생각해보세요.") {
                    전송 완료는 completion 핸들러로 알 수 있습니다.
                    isComplete는 메시지의 끝을 나타냅니다.
                }
            }
            
            @Choice(isCorrect: true) {
                이 데이터가 현재 메시지의 마지막임을 나타낸다.
                
                @Justification(reaction: "정확합니다! 🎯") {
                    isComplete: true는 현재 메시지가 완료되었음을 의미합니다.
                    프레이밍이 설정된 경우 메시지 경계로 인식됩니다.
                }
            }
            
            @Choice(isCorrect: false) {
                연결을 종료하라는 신호다.
                
                @Justification(reaction: "아쉽습니다.") {
                    연결 종료는 cancel() 메서드나 
                    .finalMessage contentContext를 사용합니다.
                }
            }
        }
        
        @MultipleChoice {
            TCP가 UDP보다 적합한 상황은?
            
            @Choice(isCorrect: true) {
                채팅 메시지처럼 모든 데이터가 순서대로 도착해야 할 때
                
                @Justification(reaction: "맞습니다! ✨") {
                    TCP는 순서 보장과 재전송 기능이 있어
                    모든 데이터가 정확히 전달되어야 하는 경우에 적합합니다.
                }
            }
            
            @Choice(isCorrect: false) {
                실시간 게임에서 빠른 위치 업데이트가 필요할 때
                
                @Justification(reaction: "틀렸습니다.") {
                    실시간 게임은 최신 데이터가 중요하고 지연이 치명적이므로
                    UDP가 더 적합한 경우가 많습니다.
                }
            }
            
            @Choice(isCorrect: false) {
                라이브 스트리밍에서 약간의 데이터 손실이 허용될 때
                
                @Justification(reaction: "다시 생각해보세요.") {
                    데이터 손실이 허용되는 경우 UDP가 더 적합합니다.
                    TCP의 재전송은 오히려 지연을 유발할 수 있습니다.
                }
            }
        }
    }
}
