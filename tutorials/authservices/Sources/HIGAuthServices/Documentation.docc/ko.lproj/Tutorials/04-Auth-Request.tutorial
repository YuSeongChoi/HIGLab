@Tutorial(time: 20) {
    @Intro(title: "인증 요청 처리") {
        인증 요청을 시작하고 Authorization Code, Identity Token 등
        인증 결과를 올바르게 처리하는 방법을 배웁니다.
        
        @Image(source: "auth-flow.png", alt: "인증 흐름도")
    }
    
    @Section(title: "인증 요청 시작") {
        @ContentAndMedia {
            인증 요청은 ASAuthorizationAppleIDRequest를 통해 구성되며,
            요청할 정보의 범위(scope)를 지정할 수 있습니다.
            
            - `requestedScopes`: 요청할 사용자 정보 범위
            - `.fullName`: 사용자 이름
            - `.email`: 사용자 이메일
        }
        
        @Steps {
            @Step {
                인증 요청을 생성하고 scope를 설정합니다.
                scope를 지정하지 않으면 User Identifier만 받습니다.
                
                @Code(name: "CreateRequest.swift", file: "04-01-create-request.swift")
            }
            
            @Step {
                nonce를 생성하여 요청에 포함합니다.
                서버에서 Identity Token을 검증할 때 사용됩니다.
                
                @Code(name: "NonceGeneration.swift", file: "04-02-nonce.swift")
            }
            
            @Step {
                SHA256으로 nonce를 해시하여 요청에 설정합니다.
                원본 nonce는 서버 검증용으로 보관합니다.
                
                @Code(name: "NonceHash.swift", file: "04-03-nonce-hash.swift")
            }
        }
    }
    
    @Section(title: "ASAuthorizationAppleIDCredential 이해") {
        @ContentAndMedia {
            인증 성공 시 받는 Credential에는 
            다양한 정보가 포함되어 있습니다.
            
            | 속성 | 설명 | 주의사항 |
            |-----|------|---------|
            | user | 고유 사용자 식별자 | 항상 제공 |
            | email | 이메일 주소 | 첫 인증 시에만 |
            | fullName | 사용자 이름 | 첫 인증 시에만 |
            | identityToken | JWT 토큰 | 서버 검증용 |
            | authorizationCode | 인증 코드 | 서버 토큰 교환용 |
        }
        
        @Steps {
            @Step {
                Credential에서 사용자 식별자를 추출합니다.
                이 값은 앱-사용자 조합에 대해 고유합니다.
                
                @Code(name: "ExtractUser.swift", file: "04-04-extract-user.swift")
            }
            
            @Step {
                identityToken을 String으로 디코딩합니다.
                이 JWT는 서버에서 검증해야 합니다.
                
                @Code(name: "IdentityToken.swift", file: "04-05-identity-token.swift")
            }
            
            @Step {
                authorizationCode를 추출합니다.
                서버에서 refresh token을 얻는 데 사용됩니다.
                
                @Code(name: "AuthCode.swift", file: "04-06-auth-code.swift")
            }
        }
    }
    
    @Section(title: "첫 인증 vs 재인증") {
        @ContentAndMedia {
            중요: email과 fullName은 최초 인증 시에만 제공됩니다.
            재인증 시에는 user(식별자)만 받을 수 있습니다.
            
            따라서 첫 인증 시 받은 정보를 
            반드시 저장해야 합니다.
        }
        
        @Steps {
            @Step {
                첫 인증인지 확인하고 사용자 정보를 저장합니다.
                email과 fullName이 nil이 아닐 때가 첫 인증입니다.
                
                @Code(name: "FirstAuth.swift", file: "04-07-first-auth.swift")
            }
            
            @Step {
                Keychain에 사용자 정보를 안전하게 저장합니다.
                UserDefaults는 민감한 정보에 적합하지 않습니다.
                
                @Code(name: "SaveCredentials.swift", file: "04-08-save-credentials.swift")
            }
            
            @Step {
                재인증 시에는 저장된 정보와 
                user 식별자를 매칭합니다.
                
                @Code(name: "ReAuthentication.swift", file: "04-09-re-auth.swift")
            }
        }
    }
    
    @Section(title: "실시간 사용자 정보(realUserStatus)") {
        @ContentAndMedia {
            realUserStatus는 사용자가 실제 사람인지 
            Apple이 판단한 결과입니다.
            
            - `.likelyReal`: 실제 사람일 가능성 높음
            - `.unknown`: 판단 불가
            - `.unsupported`: 지원되지 않음
            
            반봇(anti-bot) 로직에 활용할 수 있습니다.
        }
        
        @Steps {
            @Step {
                realUserStatus를 확인하여 
                봇 계정을 필터링합니다.
                
                @Code(name: "RealUserStatus.swift", file: "04-10-real-user.swift")
            }
            
            @Step {
                unknown 상태에서는 추가 검증을 고려합니다.
                CAPTCHA나 이메일 인증 등을 활용합니다.
                
                @Code(name: "AdditionalVerification.swift", file: "04-11-additional-verify.swift")
            }
        }
    }
    
    @Assessments {
        @MultipleChoice {
            email과 fullName은 언제 제공되나요?
            
            @Choice(isCorrect: true) {
                최초 인증 시에만 제공된다.
                
                @Justification(reaction: "정확합니다! 🎯") {
                    사용자 프라이버시 보호를 위해
                    첫 인증 시에만 제공됩니다.
                    반드시 저장해두세요.
                }
            }
            
            @Choice(isCorrect: false) {
                매 인증 시마다 제공된다.
                
                @Justification(reaction: "틀렸습니다.") {
                    재인증 시에는 user 식별자만 제공됩니다.
                }
            }
            
            @Choice(isCorrect: false) {
                scope에 포함하면 항상 제공된다.
                
                @Justification(reaction: "아쉽습니다.") {
                    scope를 요청해도 재인증 시에는 nil입니다.
                }
            }
        }
        
        @MultipleChoice {
            nonce를 사용하는 주요 목적은?
            
            @Choice(isCorrect: false) {
                사용자 인터페이스 커스터마이징.
                
                @Justification(reaction: "관계 없습니다.") {
                    nonce는 보안 관련 기능입니다.
                }
            }
            
            @Choice(isCorrect: true) {
                서버에서 Identity Token의 유효성을 검증.
                
                @Justification(reaction: "맞습니다! ✨") {
                    nonce는 replay attack을 방지하고
                    토큰의 무결성을 확인합니다.
                }
            }
            
            @Choice(isCorrect: false) {
                사용자 식별자 생성에 사용.
                
                @Justification(reaction: "틀렸습니다.") {
                    user 식별자는 Apple이 자동 생성합니다.
                }
            }
        }
    }
}
