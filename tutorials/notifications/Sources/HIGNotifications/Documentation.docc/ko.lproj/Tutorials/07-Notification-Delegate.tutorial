@Tutorial(time: 20) {
    @Intro(title: "알림 처리 (Delegate)") {
        앱이 실행 중일 때와 백그라운드에서 알림을 처리하는 방법을 배웁니다.
        
        UNUserNotificationCenterDelegate를 구현하여
        알림 표시 방식과 사용자 응답을 제어합니다.
    }
    
    @Section(title: "UNUserNotificationCenterDelegate 소개") {
        @ContentAndMedia {
            이 델리게이트는 두 가지 핵심 메서드를 제공합니다:
            
            1. **willPresent**: 앱이 포어그라운드일 때 알림 표시 방식 결정
            2. **didReceive**: 사용자가 알림과 상호작용했을 때 응답 처리
        }
        
        @Steps {
            @Step {
                **델리게이트 설정**
                
                UNUserNotificationCenter의 delegate를 설정합니다.
                앱 시작 초기에 설정해야 합니다.
                
                @Code(name: "SetDelegate.swift", file: "07-set-delegate.swift")
            }
            
            @Step {
                **AppDelegate에서 설정**
                
                @UIApplicationDelegateAdaptor를 사용하여 
                앱 시작 시 델리게이트를 설정합니다.
                
                @Code(name: "AppDelegateSetup.swift", file: "07-app-delegate-setup.swift")
            }
        }
    }
    
    @Section(title: "포어그라운드 알림 처리 (willPresent)") {
        @ContentAndMedia {
            기본적으로 앱이 포어그라운드에 있을 때는 알림이 표시되지 않습니다.
            
            willPresent 메서드에서 표시 옵션을 반환하여
            배너, 소리, 배지 등을 제어합니다.
        }
        
        @Steps {
            @Step {
                **willPresent 메서드 구현**
                
                앱이 활성화된 상태에서 알림이 도착하면 호출됩니다.
                어떤 방식으로 표시할지 결정합니다.
                
                @Code(name: "WillPresent.swift", file: "07-will-present.swift")
            }
            
            @Step {
                **표시 옵션 선택**
                
                상황에 따라 다른 표시 방식을 선택할 수 있습니다.
                - 빈 배열: 표시하지 않음
                - [.banner, .sound]: 배너와 소리
                - [.list]: 알림 센터에만 추가
                
                @Code(name: "PresentationOptions.swift", file: "07-presentation-options.swift")
            }
            
            @Step {
                **조건부 표시**
                
                현재 화면이나 알림 내용에 따라 다르게 처리합니다.
                이미 해당 화면을 보고 있다면 굳이 표시하지 않을 수 있습니다.
                
                @Code(name: "ConditionalPresent.swift", file: "07-conditional-present.swift")
            }
        }
    }
    
    @Section(title: "알림 응답 처리 (didReceive)") {
        @ContentAndMedia {
            사용자가 알림을 탭하거나 액션 버튼을 누르면 didReceive가 호출됩니다.
            
            알림에 포함된 데이터를 읽고 적절한 화면으로 이동하거나
            백그라운드에서 작업을 수행합니다.
        }
        
        @Steps {
            @Step {
                **didReceive 메서드 구현**
                
                response 파라미터에서 알림 정보와 액션을 확인합니다.
                completionHandler를 반드시 호출해야 합니다.
                
                @Code(name: "DidReceive.swift", file: "07-did-receive.swift")
            }
            
            @Step {
                **기본 탭과 액션 구분**
                
                actionIdentifier로 어떤 상호작용인지 구분합니다.
                - UNNotificationDefaultActionIdentifier: 알림 탭
                - UNNotificationDismissActionIdentifier: 알림 닫기
                - 커스텀 액션 ID
                
                @Code(name: "ActionIdentifier.swift", file: "07-action-identifier.swift")
            }
            
            @Step {
                **userInfo에서 데이터 추출**
                
                알림에 첨부한 커스텀 데이터를 읽어 화면 이동에 활용합니다.
                
                @Code(name: "ExtractUserInfo.swift", file: "07-extract-userinfo.swift")
            }
        }
    }
    
    @Section(title: "딥링크 네비게이션") {
        @ContentAndMedia {
            알림 탭 시 앱의 특정 화면으로 이동하는 패턴을 구현합니다.
            
            NavigationPath나 @Environment를 활용하여
            SwiftUI 앱에서 깔끔하게 네비게이션합니다.
        }
        
        @Steps {
            @Step {
                **네비게이션 상태 관리**
                
                알림에서 열어야 할 화면 정보를 앱 상태로 관리합니다.
                @Observable 객체를 사용합니다.
                
                @Code(name: "NavigationState.swift", file: "07-navigation-state.swift")
            }
            
            @Step {
                **딥링크 열거형 정의**
                
                앱에서 지원하는 딥링크 목적지를 정의합니다.
                
                @Code(name: "DeepLink.swift", file: "07-deep-link.swift")
            }
            
            @Step {
                **알림에서 딥링크 트리거**
                
                didReceive에서 딥링크 상태를 업데이트합니다.
                
                @Code(name: "TriggerDeepLink.swift", file: "07-trigger-deep-link.swift")
            }
            
            @Step {
                **SwiftUI 뷰에서 반응**
                
                딥링크 상태 변화에 따라 네비게이션을 수행합니다.
                
                @Code(name: "ReactToDeepLink.swift", file: "07-react-to-deep-link.swift")
            }
        }
    }
    
    @Section(title: "액션 응답 처리 완성") {
        @ContentAndMedia {
            Chapter 5에서 정의한 액션들의 실제 처리 로직을 완성합니다.
            
            "완료", "스누즈", "삭제" 각 액션에 대한 비즈니스 로직을 구현합니다.
        }
        
        @Steps {
            @Step {
                **완료 액션 처리**
                
                리마인더를 완료 상태로 변경합니다.
                데이터베이스 업데이트와 UI 갱신을 처리합니다.
                
                @Code(name: "CompleteAction.swift", file: "07-complete-action.swift")
            }
            
            @Step {
                **스누즈 액션 처리**
                
                새로운 알림을 10분 후로 예약합니다.
                원래 알림 정보를 유지합니다.
                
                @Code(name: "SnoozeAction.swift", file: "07-snooze-action.swift")
            }
            
            @Step {
                **전체 응답 핸들러 완성**
                
                모든 액션을 처리하는 완전한 didReceive 구현입니다.
                
                @Code(name: "FullResponseHandler.swift", file: "07-full-response-handler.swift")
            }
        }
    }
    
    @Assessments {
        @MultipleChoice {
            앱이 포어그라운드에 있을 때 알림 배너를 표시하려면 어떻게 해야 할까요?
            
            @Choice(isCorrect: false) {
                기본적으로 표시됩니다
                
                @Justification(reaction: "아쉽네요") {
                    기본적으로 포어그라운드 알림은 표시되지 않습니다.
                    willPresent 델리게이트에서 명시적으로 설정해야 합니다.
                }
            }
            
            @Choice(isCorrect: true) {
                willPresent 델리게이트에서 .banner 옵션을 반환
                
                @Justification(reaction: "정답!") {
                    willPresent의 completionHandler에 [.banner] 등의 옵션을 
                    전달하면 포어그라운드에서도 알림이 표시됩니다.
                }
            }
            
            @Choice(isCorrect: false) {
                Info.plist에 설정 추가
                
                @Justification(reaction: "아쉽네요") {
                    Info.plist가 아니라 코드에서 델리게이트를 구현해야 합니다.
                }
            }
        }
        
        @MultipleChoice {
            사용자가 알림 배너를 탭했을 때의 actionIdentifier는?
            
            @Choice(isCorrect: true) {
                UNNotificationDefaultActionIdentifier
                
                @Justification(reaction: "정답!") {
                    기본 탭(액션 버튼이 아닌)은 
                    UNNotificationDefaultActionIdentifier로 식별됩니다.
                }
            }
            
            @Choice(isCorrect: false) {
                "tap"
                
                @Justification(reaction: "아쉽네요") {
                    시스템 정의 상수인 UNNotificationDefaultActionIdentifier를 사용합니다.
                }
            }
            
            @Choice(isCorrect: false) {
                nil
                
                @Justification(reaction: "아쉽네요") {
                    항상 actionIdentifier가 있습니다.
                    기본 탭은 UNNotificationDefaultActionIdentifier입니다.
                }
            }
        }
        
        @MultipleChoice {
            didReceive 델리게이트 메서드에서 completionHandler 호출을 잊으면?
            
            @Choice(isCorrect: true) {
                시스템이 작업이 완료되지 않은 것으로 판단하여 문제가 발생할 수 있음
                
                @Justification(reaction: "주의가 필요합니다!") {
                    completionHandler는 반드시 호출해야 합니다.
                    그렇지 않으면 시스템이 앱을 종료하거나 
                    이후 알림 처리에 문제가 생길 수 있습니다.
                }
            }
            
            @Choice(isCorrect: false) {
                아무 문제 없음
                
                @Justification(reaction: "위험합니다") {
                    completionHandler 미호출은 심각한 문제를 야기합니다.
                    항상 호출하세요.
                }
            }
            
            @Choice(isCorrect: false) {
                앱이 즉시 크래시함
                
                @Justification(reaction: "정확하지 않습니다") {
                    즉시 크래시하지는 않지만, 타임아웃 후 시스템이 
                    앱을 강제 종료할 수 있습니다.
                }
            }
        }
    }
}
