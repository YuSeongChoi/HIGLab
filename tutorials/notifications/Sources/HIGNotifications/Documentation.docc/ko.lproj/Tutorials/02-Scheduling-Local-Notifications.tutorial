@Tutorial(time: 18) {
    @Intro(title: "로컬 알림 예약") {
        로컬 알림은 서버 없이 디바이스에서 직접 생성됩니다.
        
        특정 시간, 위치, 또는 조건에 따라 알림을 예약하고
        사용자에게 중요한 순간을 놓치지 않게 합니다.
    }
    
    @Section(title: "UNNotificationRequest 이해하기") {
        @ContentAndMedia {
            알림 요청은 세 가지 필수 요소로 구성됩니다:
            
            1. **identifier**: 고유 식별자 (수정/삭제에 사용)
            2. **content**: 알림 내용 (제목, 본문, 소리 등)
            3. **trigger**: 발동 조건 (시간, 위치, 캘린더)
        }
        
        @Steps {
            @Step {
                **알림 요청의 구조**
                
                UNNotificationRequest를 생성하는 기본 패턴입니다.
                identifier는 UUID를 사용하는 것이 좋습니다.
                
                @Code(name: "RequestStructure.swift", file: "02-request-structure.swift")
            }
            
            @Step {
                **UNNotificationContent 설정**
                
                UNMutableNotificationContent로 알림 내용을 구성합니다.
                title, body, sound는 가장 기본적인 속성입니다.
                
                @Code(name: "BasicContent.swift", file: "02-basic-content.swift")
            }
        }
    }
    
    @Section(title: "시간 기반 트리거") {
        @ContentAndMedia {
            UNTimeIntervalNotificationTrigger는 가장 간단한 트리거입니다.
            
            "N초 후에 알림"을 설정합니다.
            테스트할 때 유용하지만, 실제로는 정확한 시간 지정이 더 많이 쓰입니다.
        }
        
        @Steps {
            @Step {
                **TimeInterval 트리거**
                
                지정한 시간(초) 후에 알림이 발생합니다.
                repeats: true로 반복 가능하지만, 최소 60초 이상이어야 합니다.
                
                @Code(name: "TimeIntervalTrigger.swift", file: "02-timeinterval-trigger.swift")
            }
            
            @Step {
                **스케줄러 메서드 구현**
                
                NotificationManager에 알림 예약 메서드를 추가합니다.
                에러 핸들링도 포함합니다.
                
                @Code(name: "ScheduleMethod.swift", file: "02-schedule-method.swift")
            }
        }
    }
    
    @Section(title: "캘린더 기반 트리거") {
        @ContentAndMedia {
            UNCalendarNotificationTrigger로 정확한 날짜와 시간에 알림을 예약합니다.
            
            DateComponents를 사용하여 원하는 시점을 지정합니다.
            이것이 리마인더 앱의 핵심 기능입니다.
        }
        
        @Steps {
            @Step {
                **특정 시각에 알림 예약**
                
                DateComponents로 연, 월, 일, 시, 분을 지정합니다.
                생략한 컴포넌트는 와일드카드처럼 동작합니다.
                
                @Code(name: "CalendarTrigger.swift", file: "02-calendar-trigger.swift")
            }
            
            @Step {
                **Date를 DateComponents로 변환**
                
                사용자가 선택한 Date를 DateComponents로 변환합니다.
                Calendar를 사용하여 정확한 컴포넌트를 추출합니다.
                
                @Code(name: "DateConversion.swift", file: "02-date-conversion.swift")
            }
            
            @Step {
                **리마인더 예약 UI 구현**
                
                DatePicker로 사용자가 알림 시간을 선택하게 합니다.
                선택한 시간에 알림을 예약합니다.
                
                @Code(name: "ReminderScheduleView.swift", file: "02-reminder-schedule-view.swift")
            }
        }
    }
    
    @Section(title: "예약된 알림 관리") {
        @ContentAndMedia {
            예약한 알림은 조회, 수정, 삭제가 가능합니다.
            
            identifier를 잘 관리하면 특정 알림만 선택적으로 제어할 수 있습니다.
            앱을 종료해도 예약된 알림은 시스템에 남아있습니다.
        }
        
        @Steps {
            @Step {
                **예약된 알림 조회**
                
                getPendingNotificationRequests로 대기 중인 알림을 조회합니다.
                async/await로 깔끔하게 처리합니다.
                
                @Code(name: "GetPending.swift", file: "02-get-pending.swift")
            }
            
            @Step {
                **특정 알림 취소**
                
                identifier로 특정 알림만 취소합니다.
                removePendingNotificationRequests를 사용합니다.
                
                @Code(name: "CancelNotification.swift", file: "02-cancel-notification.swift")
            }
            
            @Step {
                **모든 알림 취소**
                
                removeAllPendingNotificationRequests로 모든 예약을 제거합니다.
                앱 로그아웃 시 유용합니다.
                
                @Code(name: "CancelAll.swift", file: "02-cancel-all.swift")
            }
            
            @Step {
                **Reminder 모델 정의**
                
                리마인더 데이터를 관리할 모델을 정의합니다.
                알림 ID를 저장하여 나중에 관리할 수 있게 합니다.
                
                @Code(name: "ReminderModel.swift", file: "02-reminder-model.swift")
            }
        }
    }
    
    @Assessments {
        @MultipleChoice {
            UNTimeIntervalNotificationTrigger에서 반복 알림을 설정할 때 최소 간격은?
            
            @Choice(isCorrect: false) {
                10초
                
                @Justification(reaction: "아쉽네요") {
                    반복 알림은 최소 60초 이상이어야 합니다.
                    시스템 리소스 보호를 위한 제한입니다.
                }
            }
            
            @Choice(isCorrect: true) {
                60초
                
                @Justification(reaction: "정확합니다!") {
                    repeats: true로 설정할 때 timeInterval은 
                    최소 60초 이상이어야 합니다.
                }
            }
            
            @Choice(isCorrect: false) {
                제한 없음
                
                @Justification(reaction: "아쉽네요") {
                    시스템은 배터리와 리소스 보호를 위해 
                    반복 간격을 최소 60초로 제한합니다.
                }
            }
        }
        
        @MultipleChoice {
            앱을 완전히 종료한 후에도 예약된 로컬 알림이 작동할까요?
            
            @Choice(isCorrect: true) {
                예, 시스템이 알림을 관리합니다
                
                @Justification(reaction: "정답!") {
                    예약된 알림은 시스템 레벨에서 관리됩니다.
                    앱이 종료되어도 지정된 시간에 알림이 발생합니다.
                }
            }
            
            @Choice(isCorrect: false) {
                아니요, 앱이 실행 중이어야 합니다
                
                @Justification(reaction: "오해입니다") {
                    로컬 알림은 시스템이 관리하므로 
                    앱 실행 여부와 관계없이 동작합니다.
                }
            }
            
            @Choice(isCorrect: false) {
                백그라운드 모드가 활성화된 경우에만
                
                @Justification(reaction: "아쉽네요") {
                    알림은 별도의 백그라운드 모드 없이도 작동합니다.
                    시스템이 직접 알림을 트리거합니다.
                }
            }
        }
        
        @MultipleChoice {
            UNNotificationRequest의 identifier는 어떤 용도로 사용될까요?
            
            @Choice(isCorrect: false) {
                알림 내용을 암호화하는 키
                
                @Justification(reaction: "아쉽네요") {
                    identifier는 암호화와 무관합니다.
                    알림 식별과 관리에 사용됩니다.
                }
            }
            
            @Choice(isCorrect: true) {
                알림을 조회, 수정, 삭제할 때 식별용
                
                @Justification(reaction: "정확합니다!") {
                    identifier로 특정 알림을 찾아 취소하거나 업데이트할 수 있습니다.
                    UUID를 사용하면 충돌 없이 고유하게 관리됩니다.
                }
            }
            
            @Choice(isCorrect: false) {
                사용자에게 표시되는 알림 제목
                
                @Justification(reaction: "혼동하지 마세요") {
                    제목은 content.title에 설정합니다.
                    identifier는 내부 식별용으로 사용자에게 보이지 않습니다.
                }
            }
        }
    }
}
