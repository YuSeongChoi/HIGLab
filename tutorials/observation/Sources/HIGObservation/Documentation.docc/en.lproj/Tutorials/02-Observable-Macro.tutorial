@Tutorial(time: 15) {
    @Intro(title: "Understanding the @Observable Macro") {
        Explore what code the @Observable macro actually generates.
        Through macro expansion, fully understand the internal workings.
    }
    
    @Section(title: "Exploring Macro Expansion") {
        @ContentAndMedia {
            Swift macros generate code at compile time.
            Let's use Xcode's "Expand Macro" feature to see
            what @Observable actually expands to.
        }
        
        @Steps {
            @Step {
                Create a simple @Observable class.
                In Xcode, right-click on `@Observable` and
                select "Expand Macro".
                
                @Code(name: "SimpleMacro.swift", file: "02-simple-macro.swift")
            }
            
            @Step {
                This is what the macro expands to.
                @Observable wraps each stored property with
                `@ObservationTracked` and automatically generates
                observation infrastructure code.
                
                @Code(name: "ExpandedMacro.swift", file: "02-expanded-macro.swift")
            }
            
            @Step {
                The key is `_$observationRegistrar`.
                This object tracks which properties are read and changed.
                
                `access()`: Tracks property reads
                `withMutation()`: Tracks property changes
                
                @Code(name: "ObservationRegistrar.swift", file: "02-observation-registrar.swift")
            }
        }
    }
    
    @Section(title: "Stored Properties vs Computed Properties") {
        @ContentAndMedia {
            Stored properties and computed properties behave differently
            in @Observable. Understanding this difference is important.
        }
        
        @Steps {
            @Step {
                **Stored properties** are automatically observed.
                The macro wraps getters/setters with tracking code.
                
                @Code(name: "StoredProperties.swift", file: "02-stored-properties.swift")
            }
            
            @Step {
                **Computed properties** are observed through their dependent stored properties.
                `subtotal` depends on `price` and `quantity`,
                so views reading `subtotal` update when either changes.
                
                @Code(name: "ComputedProperties.swift", file: "02-computed-properties.swift")
            }
            
            @Step {
                Note: If a computed property depends on **external data**,
                automatic tracking won't work.
                
                Example: `Date()` isn't an @Observable property,
                so the view won't update as time passes.
                
                @Code(name: "ExternalDependency.swift", file: "02-external-dependency.swift")
            }
        }
    }
    
    @Section(title: "CartFlow: Building the Product List View") {
        @ContentAndMedia {
            Based on what we've learned, let's add
            a product list view to the CartFlow app.
            Thanks to @Observable's automatic tracking, the code is very clean.
        }
        
        @Steps {
            @Step {
                Create a product card view.
                It directly receives and displays a Product object.
                No special property wrapper needed - just a regular property!
                
                @Code(name: "ProductCard.swift", file: "02-product-card.swift")
            }
            
            @Step {
                Create a product list view.
                It fetches and displays the product list from CartStore.
                
                @Code(name: "ProductListView.swift", file: "02-product-list.swift")
            }
            
            @Step {
                Update the app's main view.
                Create CartStore with @State and pass it to child views.
                
                @Code(name: "CartFlowApp.swift", file: "02-main-view.swift")
            }
        }
    }
    
    @Assessments {
        @MultipleChoice {
            What is the core object generated by the @Observable macro?
            
            @Choice(isCorrect: true) {
                ObservationRegistrar - tracks property access and changes
                
                @Justification(reaction: "Correct!") {
                    ObservationRegistrar tracks which properties are read and changed
                    through access() and withMutation().
                }
            }
            
            @Choice(isCorrect: false) {
                ObjectWillChangePublisher - publishes notifications before changes
                
                @Justification(reaction: "Not quite") {
                    ObjectWillChangePublisher is used in ObservableObject.
                    @Observable uses ObservationRegistrar.
                }
            }
            
            @Choice(isCorrect: false) {
                StateObject - manages state objects
                
                @Justification(reaction: "Not quite") {
                    @StateObject is a SwiftUI property wrapper.
                    It's unrelated to @Observable's internal implementation.
                }
            }
        }
        
        @MultipleChoice {
            Which statement is correct about computed property observation?
            
            @Choice(isCorrect: true) {
                It's automatically tracked when dependent stored properties change
                
                @Justification(reaction: "Perfect!") {
                    Computed properties are indirectly observed through
                    the stored properties they read internally.
                }
            }
            
            @Choice(isCorrect: false) {
                You need to add @Published separately to observe them
                
                @Justification(reaction: "Not quite") {
                    @Published is for ObservableObject.
                    In @Observable, tracking is automatic.
                }
            }
            
            @Choice(isCorrect: false) {
                Computed properties cannot be observed
                
                @Justification(reaction: "Not quite") {
                    They're indirectly observed through their dependent stored properties.
                }
            }
        }
    }
}
