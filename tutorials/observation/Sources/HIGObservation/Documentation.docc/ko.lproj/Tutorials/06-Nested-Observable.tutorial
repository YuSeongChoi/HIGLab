@Tutorial(time: 12) {
    @Intro(title: "중첩된 Observable 객체") {
        Observable 객체 안에 다른 Observable 객체를 포함하는 패턴을 배웁니다.
        중첩 구조에서의 관찰 동작과 주의점을 이해합니다.
    }
    
    @Section(title: "중첩 Observable의 기본") {
        @ContentAndMedia {
            실제 앱에서는 하나의 객체가 다른 Observable 객체를 
            프로퍼티로 가지는 경우가 많습니다.
            이 중첩 구조에서 관찰이 어떻게 동작하는지 살펴봅니다.
        }
        
        @Steps {
            @Step {
                기본적인 중첩 구조입니다.
                User 안에 Address가 Observable로 포함되어 있습니다.
                
                @Code(name: "NestedBasic.swift", file: "06-nested-basic.swift")
            }
            
            @Step {
                중요한 점: **참조 변경만 감지됩니다!**
                address 자체를 교체하면 감지되지만,
                address.city를 변경하면 User 수준에서는 감지되지 않습니다.
                
                @Code(name: "ReferenceVsValue.swift", file: "06-reference-vs-value.swift")
            }
            
            @Step {
                내부 객체의 변화를 감지하려면
                해당 프로퍼티를 **직접 접근**해야 합니다.
                
                @Code(name: "DirectAccess.swift", file: "06-direct-access.swift")
            }
        }
    }
    
    @Section(title: "중첩 구조 설계 패턴") {
        @ContentAndMedia {
            중첩 Observable을 효과적으로 사용하기 위한
            설계 패턴과 모범 사례를 알아봅니다.
        }
        
        @Steps {
            @Step {
                **패턴 1**: 평면 구조 유지하기
                가능하면 중첩을 피하고 평면적으로 설계합니다.
                
                @Code(name: "FlatStructure.swift", file: "06-flat-structure.swift")
            }
            
            @Step {
                **패턴 2**: 중첩이 필요한 경우 - 뷰 분리
                각 Observable 수준에 맞는 뷰를 만들어
                자연스럽게 추적되도록 합니다.
                
                @Code(name: "ViewSeparation.swift", file: "06-view-separation.swift")
            }
            
            @Step {
                **패턴 3**: 컴포지션 패턴
                여러 Observable을 조합하여 복잡한 상태를 관리합니다.
                
                @Code(name: "CompositionPattern.swift", file: "06-composition-pattern.swift")
            }
        }
    }
    
    @Section(title: "CartFlow: 주문 배송지 관리") {
        @ContentAndMedia {
            CartFlow에 배송지 정보를 관리하는 기능을 추가합니다.
            중첩 Observable 패턴을 실전에 적용해봅니다.
        }
        
        @Steps {
            @Step {
                배송지 정보를 담는 ShippingAddress 모델을 만듭니다.
                
                @Code(name: "ShippingAddress.swift", file: "06-shipping-address.swift")
            }
            
            @Step {
                주문 정보 OrderStore를 만들고 ShippingAddress를 포함시킵니다.
                
                @Code(name: "OrderStore.swift", file: "06-order-store.swift")
            }
            
            @Step {
                배송지 편집 뷰를 만들어 중첩 Observable을 활용합니다.
                @Bindable을 통해 양방향 바인딩도 가능합니다.
                
                @Code(name: "ShippingAddressView.swift", file: "06-shipping-view.swift")
            }
        }
    }
    
    @Assessments {
        @MultipleChoice {
            중첩된 Observable에서 내부 객체의 프로퍼티 변화를 감지하려면?
            
            @Choice(isCorrect: true) {
                뷰에서 내부 객체의 프로퍼티를 직접 접근해야 함
                
                @Justification(reaction: "정답!") {
                    예를 들어 user.address.city를 읽으면
                    address의 city 변화가 자동으로 추적됩니다.
                }
            }
            
            @Choice(isCorrect: false) {
                외부 객체만 관찰하면 내부도 자동으로 감지됨
                
                @Justification(reaction: "아쉽네요") {
                    아닙니다. 외부 객체는 참조 변경만 감지합니다.
                    내부 객체의 프로퍼티 변화는 직접 접근해야 추적됩니다.
                }
            }
            
            @Choice(isCorrect: false) {
                특별한 매크로를 추가해야 함
                
                @Justification(reaction: "아쉽네요") {
                    추가 매크로는 필요 없습니다.
                    필요한 프로퍼티를 직접 읽으면 됩니다.
                }
            }
        }
        
        @MultipleChoice {
            중첩 Observable 구조에서 가장 권장되는 설계 방식은?
            
            @Choice(isCorrect: true) {
                각 Observable 수준에 맞는 작은 뷰로 분리
                
                @Justification(reaction: "완벽합니다!") {
                    뷰를 분리하면 각 뷰가 필요한 수준의 Observable만
                    자연스럽게 추적하게 되어 최적의 성능을 얻습니다.
                }
            }
            
            @Choice(isCorrect: false) {
                모든 프로퍼티를 최상위 객체에 평면화
                
                @Justification(reaction: "아쉽네요") {
                    평면화가 항상 좋은 것은 아닙니다.
                    논리적인 그룹핑을 유지하면서 뷰를 적절히 분리하세요.
                }
            }
            
            @Choice(isCorrect: false) {
                중첩을 절대 사용하지 않기
                
                @Justification(reaction: "아쉽네요") {
                    중첩 구조는 복잡한 도메인을 표현하는 데 유용합니다.
                    적절한 뷰 분리와 함께 사용하면 됩니다.
                }
            }
        }
    }
}
