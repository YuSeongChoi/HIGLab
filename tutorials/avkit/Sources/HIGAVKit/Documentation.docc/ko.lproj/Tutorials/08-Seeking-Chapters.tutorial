@Tutorial(time: 25) {
    @Intro(title: "시간 이동 & 챕터") {
        정밀한 탐색(seeking)과 챕터 네비게이션을 구현하여
        사용자가 원하는 위치로 쉽게 이동할 수 있게 합니다.
        
        @Image(source: "seeking-chapters.png", alt: "시간 이동과 챕터")
    }
    
    @Section(title: "기본 탐색(Seeking)") {
        @ContentAndMedia {
            seek(to:) 메서드로 특정 시간 위치로 이동합니다.
            CMTime을 사용해 정밀한 시간을 지정합니다.
            
            - 초 단위 이동
            - 백분율 기반 이동
            - 완료 핸들러
        }
        
        @Steps {
            @Step {
                CMTime을 사용해 특정 시간으로 이동합니다.
                
                @Code(name: "BasicSeek.swift", file: "08-01-basic-seek.swift")
            }
            
            @Step {
                seek 완료 후 콜백을 받아 UI를 업데이트합니다.
                
                @Code(name: "SeekCompletion.swift", file: "08-02-seek-completion.swift")
            }
            
            @Step {
                상대적 시간 이동을 구현합니다.
                현재 위치에서 ±10초, ±30초 등 이동합니다.
                
                @Code(name: "RelativeSeek.swift", file: "08-03-relative-seek.swift")
            }
        }
    }
    
    @Section(title: "정밀 탐색") {
        @ContentAndMedia {
            toleranceBefore와 toleranceAfter로 
            탐색 정밀도를 조절합니다.
            
            - 빠른 탐색: 넓은 tolerance
            - 정밀 탐색: zero tolerance
            - 키프레임 기반 탐색
        }
        
        @Steps {
            @Step {
                toleranceBefore/After를 .zero로 설정하면
                정확한 위치로 이동하지만 시간이 더 걸립니다.
                
                @Code(name: "PreciseSeek.swift", file: "08-04-precise-seek.swift")
            }
            
            @Step {
                빠른 탐색이 필요하면 넓은 tolerance를 사용합니다.
                가장 가까운 키프레임으로 이동합니다.
                
                @Code(name: "FastSeek.swift", file: "08-05-fast-seek.swift")
            }
            
            @Step {
                슬라이더 드래그 중에는 빠른 탐색을,
                드래그 종료 시에는 정밀 탐색을 사용합니다.
                
                @Code(name: "SmartSeek.swift", file: "08-06-smart-seek.swift")
            }
        }
    }
    
    @Section(title: "타임라인 슬라이더") {
        @ContentAndMedia {
            사용자가 직접 시간을 선택할 수 있는
            타임라인 슬라이더를 구현합니다.
            
            - 드래그 중 미리보기
            - 버퍼 상태 표시
            - 썸네일 프리뷰
        }
        
        @Steps {
            @Step {
                Slider를 사용해 타임라인을 구현합니다.
                
                @Code(name: "TimelineSlider.swift", file: "08-07-timeline-slider.swift")
            }
            
            @Step {
                드래그 중에는 재생을 일시정지하고
                종료 시 해당 위치에서 재생을 재개합니다.
                
                @Code(name: "SliderDrag.swift", file: "08-08-slider-drag.swift")
            }
            
            @Step {
                AVAssetImageGenerator로 
                특정 시간의 썸네일을 생성합니다.
                
                @Code(name: "ThumbnailGenerator.swift", file: "08-09-thumbnail.swift")
            }
            
            @Step {
                슬라이더 위에 썸네일 프리뷰를 표시합니다.
                
                @Code(name: "ThumbnailPreview.swift", file: "08-10-thumbnail-preview.swift")
            }
        }
    }
    
    @Section(title: "챕터 네비게이션") {
        @ContentAndMedia {
            비디오에 내장된 챕터 정보를 읽고
            챕터 기반 네비게이션을 구현합니다.
            
            - 챕터 메타데이터 읽기
            - 챕터 목록 표시
            - 챕터 간 이동
        }
        
        @Steps {
            @Step {
                AVAsset에서 챕터 메타데이터를 로드합니다.
                chapterMetadataGroups로 챕터 정보를 가져옵니다.
                
                @Code(name: "LoadChapters.swift", file: "08-11-load-chapters.swift")
            }
            
            @Step {
                챕터 목록 UI를 구현합니다.
                각 챕터의 제목과 시작 시간을 표시합니다.
                
                @Code(name: "ChapterList.swift", file: "08-12-chapter-list.swift")
            }
            
            @Step {
                챕터를 탭하면 해당 시간으로 이동합니다.
                
                @Code(name: "ChapterNavigation.swift", file: "08-13-chapter-nav.swift")
            }
            
            @Step {
                이전/다음 챕터 버튼을 구현합니다.
                현재 재생 위치를 기준으로 챕터를 찾습니다.
                
                @Code(name: "ChapterButtons.swift", file: "08-14-chapter-buttons.swift")
            }
        }
    }
    
    @Assessments {
        @MultipleChoice {
            toleranceBefore와 toleranceAfter를 .zero로 설정하면 어떻게 되나요?
            
            @Choice(isCorrect: true) {
                정확한 시간 위치로 이동하지만 탐색 시간이 더 걸린다
                
                @Justification(reaction: "정확합니다! 🎯") {
                    zero tolerance는 정확한 위치를 찾기 위해
                    디코딩 작업이 추가로 필요합니다.
                }
            }
            
            @Choice(isCorrect: false) {
                탐색이 실패한다
                
                @Justification(reaction: "틀렸습니다.") {
                    탐색은 성공하지만 더 오래 걸립니다.
                }
            }
            
            @Choice(isCorrect: false) {
                항상 키프레임으로만 이동한다
                
                @Justification(reaction: "반대입니다.") {
                    zero tolerance는 키프레임이 아닌 
                    정확한 위치로 이동합니다.
                }
            }
        }
        
        @MultipleChoice {
            슬라이더 드래그 중 최적의 seek 전략은?
            
            @Choice(isCorrect: false) {
                항상 정밀 탐색(.zero tolerance)을 사용한다
                
                @Justification(reaction: "성능 문제가 있습니다.") {
                    드래그 중에는 빠른 피드백이 더 중요합니다.
                }
            }
            
            @Choice(isCorrect: true) {
                드래그 중에는 빠른 탐색, 종료 시 정밀 탐색을 사용한다
                
                @Justification(reaction: "맞습니다! ✨") {
                    드래그 중에는 빠른 피드백을,
                    최종 위치에서는 정확성을 제공합니다.
                }
            }
            
            @Choice(isCorrect: false) {
                드래그 종료 시에만 seek한다
                
                @Justification(reaction: "사용자 경험이 좋지 않습니다.") {
                    드래그 중에도 미리보기가 있어야 좋습니다.
                }
            }
        }
    }
}
